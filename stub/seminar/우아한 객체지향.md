# 우아한 객체지향

## 세미나 정보

제목: 우아한 객체지향 - 의존성을 이용해 설계 진화시키기

발표자: 우아한형제들 개발실장 조영호

세미나 이름: 우아한테크세미나

일시: 2019년 6월 20일

참고자료

* [발표 영상](https://youtu.be/dJ5C4qRqAgA)
* [발표 자료](https://www.slideshare.net/baejjae93/ss-151545329)
* [우아한 객체지향 세미나 1단계](https://github.com/eternity-oop/Woowahan-OO-01-object-reference)
* [우아한 객체지향 세미나 2단계](https://github.com/eternity-oop/Woowahan-OO-02-domain-service)
* [우아한 객체지향 세미나 3단계](https://github.com/eternity-oop/Woowahan-OO-03-domain-event)

## 시작하며

설계의 핵심은 **의존성**이다. 객체 지향을 이야기할 때 역할과 책임에 대하여 연급하지만 실질적으로 역할과 책임이 필요한 것은 의존성을 어떻게 관리하는 것이냐이다.

## 의존성

설계란 코드를 어떻게 배치할 것이냐에 대한 의사 결정을 말한다. 설계의 초점은 변경이다. 같이 변경되는 코드를 같이 배치하고 그렇지 않은 코드는 따로 배치해야한다. 이때 변경의
핵심은 의존성이다.

의존성이란 변경에 의해서 영향을 받을 수 있는 가능성이다. A가 B에 의존한다는 것은 B가 변경될 때 A도 함께 변경될 가능성이 있다는 것이다.

### 의존성의 종류

의존성에는 클래스 간의 의존성, 패키지 간의 의존성이 있다. 클래스 의존성은 또 다시 4가지로 나뉜다.

- Association(연관 관계): A에서 B로 **영구적인 관계**를 맺는 관계
- Dependency(의존 관계): A에서 B로 협력을 하는 시점에 **일시적으로 관계**를 맺고 헤어지는 관계
- Inheritance(상속 관계): 부모의 구현이 변경될 때 자식의 구현이 변경될 수 있으므로 의존 관계
- Realization(실체화 관계): interface의 method signature가 변경될 때 구현하는 class가 변경될 수 있으므로 의존 관계

패키지 의존성은 한 패키지 안의 클래스가 다른 패키지의 클래스와 의존성이 있을 때 두 패키지 사이에 의존성이 있다고 말한다. 패키지 의존성을 간단하게 확인하는
방법은 `import`를 확인하는 것이다.

### 좋은 의존성을 위한 습관

- 양방향 의존성을 피하라
    - 클래스 A와 B가 양방향으로 의존성이 있는 경우 A가 바뀔 때 B가 바뀌고, B가 바뀔 때 A가 바뀐다. 이 경우 하나의 클래스에 있어야할 것을 억지로 분리한 것일 수도
      있다.
    - 클래스 A와 B의 상태를 동기화 해야하므로 신경 쓸 것이 많아진다. 버그가 생길 가능성이 높아지거나 성능 이슈가 발생할 수 있다.
- 다중성이 적은 방향을 선택하라
    - many to one을 고려하라
    - one to many로 방향을 잡으면 컬렉션을 사용하는데서 발생하는 이슈가 많다.
- 의존성이 필요없다면 제거하라
- 패키지 사이의 의존성 사이클을 제거하라
    - 패키지에 양방향 의존성(cycle)이 있어선 안된다. 패키지 사이클이 존재한다면 같은 패키지에 있어야 했던 건 아닐까 의문을 품거나 DI 등을 이용하여 의존성을
      역전하자.

## 주문 예제

### 데이터베이스와 객체의 차이

데이터베이스는 외래키 하나로 여러 테이블로 이동할 수 있지만 객체는 정해진 방향으로만 갈 수 있다.

### 관계

> 지금부터 이야기할 관계는 Layered architecture에서 domain layer에 해당한다.

관계란 어떤 객체가 어떤 방식으로 의존할 것을 말한다. 두 클래스 간에 관계가 있다는 것은 한 클래스의 인스턴스가 다른 클래스의 인스턴스와 협력하는 것을 말한다. 계의 방향이
협력의 방향이며 의존성의 방향이다.

관계의 종류를 결정하는 방법은 다음과 같다.

- Association(연관 관계): 협력을 위해 필요한 영구적인 탐색 구조. 두 객체 사이에 협력이 필요하고 관계가 영구적일 때 적절하다.
- Dependency(의존 관계): 협력을 위해 필요한 일시적인 탐색 구조. 한 객체에서 다른 객체로 항상 갈 필요가 없을 때 적절하다.

연관 관계는 탐색 가능성과 같다. Order에서 OrderLineItem으로 one to many 연관 관계를 가지고 있다면 Order를 알 때 원하는 OrderLineItem을
찾을 수 있다.

### 객체의 message

어떤 객체가 message를 받는다는 것은 객체에 public method로 구현된다는 것을 말한다. method가 필요한 이유는 message를 받기 때문이다. message를
결정한 후 method를 만드는 것이지 반대의 개념이 아니다.

## 설계 개선하기

설계를 개선하는 것은 객체들이 어떻게 협력하는지 파악하고 특정 method가 해당 class에 있어야하는지 의문을 갖는 것에서 출발한다.

클래스 간의 의존성을 종이에 그려봤을 때 어색한 점이 있다면 실제 코드에 이상한 부분이 있다.

처음부터 의존성을 잘 관리한 코드를 만들기란 어렵다. 글 쓰기처럼 절차적으로 짠 후 의존성을 파악한 후 좋은 의존성으로 개선하는 방향으로 나아가면 좋은 코드를 만들 수 있다.

### 중간 객체를 이용한 의존성 끊기

`Order`에서 `Shop`으로 메세지를 보내고 `OptionSpecifation`에서 `OrderOption`으로 메시지를 보내는 사이클을 해결하려면 어떻게 해야할까?

`Option`이라는 중간 객체를 `order` 패키지에 `Order`가 패키지 내부의 `Option`에 의존하고 `OptionSpecification`은 패키지 외부의
Option에 의존하도록
만들어 Order에서 Shop으로 의존성이 단방향으로 흐르게 개선한다.

사람들은 추상화가 추상 클래스나 인터페이스여야한다는 선입견을 갖고 있다. 그러나 추상화는 잘 변하지 않는 것을 말한다. 어떤 것에 비해 잘 변하지 않는다는 것은 추상적이다는 것을
말한다. 또, 중간 객체를 사용한다는 것이 중요한 게 아니다. 의존성을 보고 개선할 방향을 찾는 습관이 중요하다.

### 객체 참조로 구현한 연관 관계의 문제점

객체 참조는 가장 결합도가 높은 의존성이다. 따라서 협력을 위해 필요하지만 두 객체 사이에 결합도가 높아진다는 단점이 있다. 모든 것을 엮기 때문에 어디든 갈 수 있고 어떤
객체라도 함께 수정할 수 있다.

또 객체 그룹의 조회 경계가 모호해져 어디까지 조회해야할 지 명확하지가 않다. 객체가 모두 연결되어있다보니 어디가 경계인지 알 수 없다. 마찬가지로 수정 시 도메인 규칙을 함께
적용할 경계가 모호하다. 다시 말해 트랜잭션의 경계가 명확하지 않다는 것이다. 이는 어떤 테이블에서 어떤 테이블까지 하나의 Lock 단위로 볼
것인지 의문이 생긴다.

모두 연결된 객체는 트랜잭션의 범위가 너무 커진다. 비즈니스 로직이 늘어날 수록 하나의 트랜잭션에서 변경해야할 상태는 늘어나고 트랜잭션은 더욱 길어진다.

서로 다른 패키지에 있는 `Shop`, `Order`, `Delivery` 사이에서 객체 참조를 하고 있는 경우 세 객체 모두가 배달 완료 트랜잭션 범위에 속한다. 이때 문제점은
세 객체의
변경 빈도가 다르다는 것이다. `Shop`의 경우 가게의 영업 상태를 변경할 수 있고 `Order`는 주문 취소 등 주문 상태가 변경될 수 있다. `Delivery`는 배달 중 등
배달
상태가 변경될 수 있다. 문제는 지금처럼 하나의 트랜잭션으로 길게 묶여있는 세 객체들이 admin 등 새로운 요구사항이 추가될 수록 트랜잭션 주기가 달라진다는 점이다. 실제로
사용자의 요청이 긴 트랜잭션으로 걸려 admin 대용량 작업의 lock으로 인해 모두 거절된 경우가 있었다. 따라서 객체 그래프를 탐색하며 상태를 수정하다보면 트랜잭션 경합으로
성능이 저하되는 상황이 빈번하게 발생할 수 있다.

### 결합도를 낮추면서 연관 관계를 구현하는 방법

연관 관계란 탐색 가능성을 말한다. 객체 참조를 통한 탐색은 강한 결합도를 가진다. 결합도를 낮추면서 연관 관계를 구현할 수 있는 방법은 없을까?

Repository를 통해 탐색하면 가능하다.

### 어떤 객체를 묶고 분리할 것인가

도메인 관점에서 그룹의 기준을 정하면 된다. 트랜잭션 안에는 같이 변경되어야하는 것을 넣는다. 같이 변경되는 것은 비즈니스에 의해 결정된다. 하나가 바뀔 때 같이 바뀔 필요가 없는
것은 묶지 않는다. 묶은 그룹은 트랜잭션, 조회, 비즈니스 제약의 단위가 된다.

- 함께 생성되고 함께 삭제되는 객체들을 함께 묶어라.
    - 본질적으로 결합도가 높은 관계이다.
- 도메인 제약사항을 공유하는 객체들을 함께 묶어라.
    - 서로 간의 제약 사항이 없는 경우 분리하라. 그러나 같은 도메인이더라도 비즈니스에 따라 다를 수 있다. 일반적인 이커머스의 장바구니는 장바구니 물품과 공유하는 제약조건이
      별로 없다. 이에 반해 배달의 민족 애플리케이션은 장바구니에 서로 다른 가게의 물품을 넣지 못한다. 이 경우 장바구니와 장바구니 물품을 하나의 그룹으로 묶어야한다.
- 가능하면 분리하라.

### 그룹 단위로 참조를 끊었다면 - 검증 로직

참조를 끊으면 다른 객체를 참조하는 검증 로직에 컴파일 에러가 발생한다. 이 경우 객체를 직접 참조하는 로직을 다른 객체로 옮기자.

객체 지향에서 유효성 검증은 여러 객체를 오가며 이루어지기 때문에 전체 로직을 한 눈에 파악하기 어렵다. 다른 객체를 직접 참조하는 검증 로직을 `Validator`로 모은다면
전체 검증 로직을 한 눈에 볼 수 있다. 예를 들어 Validator 안에서주문을 검증할 때 주문에 필요한 메뉴, 가게 정보를 Repository에서 연관 관계를 맺어 검증한다.

사람들은 보통 객체 안에 검증 로직이 있어야한다는 고정 관념을 가지고 있다. 객체의 상태를 조금 검증하는 것이라면 객체 안에 있어도 되지만 객체를 검증하기 위해 여러 객체를
참조해야한다면 응집도가 확 떨어진다. 이 경우 검증 로직을 분리해야한다.

`Order`의 주문 처리과 검증 로직은 서로 변경의 주기가 다르다. 변경 주기가 다른 코드가 함께 있으므로 응집도가 낮을 수밖에 없다. 이를 `Validator`로 옮기면 객체의
응집도를 높이고 SRP를 만족시킬 수 있다.

이처럼 `Validator`에서 검증 로직을 절차지향으로 처리하는 것이 객체지향보다 좋을 때도 있다. 그러나 이 경우 단위 테스트가 어려울 수 있다는 trade-off가 존재한다.

### 그룹 단위로 참조를 끊었다면 - 순차적인 도메인 로직

참조를 끊으면 순차적인 도메인 로직에도 컴파일 에러가 발생한다. 이를 해결하기 위한 방법은 두 가지가 있다.

첫 번째로 `OrderDeliveredService`와 같은 별도의 서비스를 생성하고 배달 완료 로직을 옮기는 것이다. 이는 `Validator`의 절차 지향과 동일하므로 비즈니스
로직이
한 눈에 보인다는 장점이 있다.

그러나 `Order` -> `Delivery`, `Delivery` -> `Order`의 양방향 의존성이 생긴다. 이러한 서비스 의존성은 interface를 이용하여 역전할 수
있다. (DIP)

`OrderDeliveredService`를 interface로 변경하고 `OrderDeliveredServiceImpl`을 delivery package에 구현한 후
`OrderDeliverService`에 DI하면 사이클 의존성을 단방향으로 개선할 수 있다.

두번째 방법은 도메인 이벤트 퍼블리싱이다. 첫 번째 방법은 로직을 한 군데로 모아 객체 간의 결합도는 낮지만 로직간의 결합도는 높이는 방법이다. 반대로 두 번째 방법은 A가 끝났을
때 B, C가 실행됐으면 좋겠지만 순서는
느슨하게 만드는 방법이다. 메시징과 상관 없이 메모리에서 돌아가는 이벤트이다. `Order`가 시작되면 이벤트를 발행하고 각각의 이벤트 핸들러가 이를 받아 관련된 로직을 처리한다.

만약 위 과정에서 패키지에 사이클이 발생한다면 패키지를 분리하고 싶을 것이다. 이때 도메인 개념이 명확해지는 경우가 많다. 패키지 사이클을 제거하기 위해 billing
package와 class를 만들다보면 정산 도메인이라는 새로운 도메인이 분리된다. 이처럼 의존성을 쫓아가다보면 도메인에 대한 개념이 바뀔 때가 많다.

### 의존성과 시스템 분리

의존성을 관리하다보면 시스템을 쉽게 분리 할 수 있다. Layer 단위로 패키지를 구분하면 의존성 관리가 되어있지 않은 경우가 많다. 이 경우 도메인을 상위 패키지로 꺼내면
의존성이 돌고 돈다. 그래서 의존성을 관리하지 않는 경우 shop, order, delivery를 앞으로 꺼내지 못하고 layer를 앞으로 꺼낼 수밖에 없다. 같은 레이어 안에서만
의존성을 관리하면 되기 때문에 가장 쉬운 방법이기 때문이다.

의존성을 관리하게 되면 도메인 단위로 모듈화 할 수 있다. 도메인이 앞으로 나오고 레이어가 안에 배치된다. 이 경우 도메인 단위로 시스템을 분리하기 매우 편하다. 덕분에 내부
이벤트(internal event, domain event)를 메세징을 이용한 외부 이벤트(external event, system event)로 보낼 수 있다. 트래픽이 굉장히
많은 경우 동기적으로 처리할 수 없다. 연쇄적으로 죽기 때문이다. 시스템을 잘게 쪼개고 system event를 발행하여 통합한다.

### 마무리하며

하나의 시스템으로 돌아가든 여러 시스템으로 돌아가든 의존성은 항상 관리해야한다. 시스템을 관리할 땐 의존성 관점에서 보고 어떤 타이밍에 어디서 끊어야하는 지 명확하게 판단할 수
있어야한다.

그래서 항상 시스템을 볼 땐 의존성을 보고 의존성을 어떻게 가는지에 따라 시스템을 진화하면 된다.

##                                                                              
