# 5) 파이프, 전면 처리와 후면 처리, 프로세스

명령어의 결과 값을 다시 명령어에 사용하고 싶을 때가 있습니다. 이를 위한 것이 바로 파이프입니다.

## 파이프

```bash
$ 명령어1 | 명령어2 | 명령어3 ...
```

파이프를 사용하면 명령어의 결과인 표준 출력을 다음 명령어의 표준 입력으로 사용할 수 있습니다.

**예시**

```bash
$ ls -al | grep text 
```

위 명령어는 ls의 결과에서 text가 들어간 값만 출력합니다.

<aside>
💡 표준 입력이 명령어의 대상이 되므로 문자열이 아닌 파일을 다음 명령어에서 실행하고 싶으면 xargs를 사용해야합니다. e.g cp 등 파일을 대상으로 하는 명령어는 파이프로 불가

</aside>

## 전면 처리와 후면 처리

### 전면 처리(Foreground Process)

전면 처리란 일반적으로 명령어를 수행하는 것을 말합니다. 명령어를 입력하면 명령어가 쉘 전면에서 실행되며 명령어 실행이 끝날 때까지 쉘은 대기합니다. 

키보드 입력은 전면 처리에서만 가능합니다.

### 후면 처리(Background Process)

쉘에서 실행한 명령어가 오래 걸리는 경우 작업이 완료될 때까지 다른 명령어를 수행할 수 없습니다. 이럴 때 후면 처리를 이용하면 명령어의 작업을 하면서 다른 명령어를 수행할 수 있습니다.

후면 처리의 입력은 입력 재지정을 통한 파일 

```bash
$ 명령어 &
```

명령어를 입력한 후 띄어쓰고 &를 입력하면 해당 명령어를 쉘 후면에서 실행합니다. 이 경우 오래 걸리는 명령어도 쉘 후면에서 실행되므로 다른 명령어를 수행할 수 있습니다.

**예시**

```bash
$ (sleep 100; echo done) &
```

<aside>
💡 ; : 해당 명령어가 실패하든 성공하든 다음 명령어를 실행
&& : 해당 명령어가 성공하면 다음 명령어를 실행
|| : 해당 명령어가 실패하면 다음 명령어를 실행

</aside>

**결과**


후면 처리로 명령어를 실행하면 해당 명령어의 작업 번호와 PID(Process ID)가 출력됩니다.

### 후면 처리 출력 시 주의사항

후면 작업을 표준 출력으로 보내면 전면 작업과 출력이 섞이게 되므로 파이프를 활용해야합니다.

<p align="center"><img src="../../images/시스템프로그래밍및보안/5) 파이프, 전면 처리와 후면 처리, 프로세스-Untitled.png"></p>

### jobs

여러 개의 후면 작업이 있을 때 현재 작업 중인 후면 작업을 출력하는 명령어입니다.

```bash
$ jobs
```

### 후면 작업 → 전면 작업

후면 작업을 전면 작업으로 전환하고 싶을 때 fg(foreground) 명령어를 활용합니다.

```bash
$ fg %작업번호
```

PID를 입력하지 않은 경우 가장 최근 작업을 전면 작업으로 전환합니다.

### 전면 작업 → 후면 작업

전면 작업을 후면 작업으로 전환하고 싶을때 bg(background) 명령어를 활용합니다.

```bash
$ ^Z # 현재 전면 작업 일시 중지
$ jobs # 중지된 전면 작업의 작업 번호 확인
$ bg %작업번호 # 후면 작업으로 전환
```

## 프로세스

실행중인 프로그램을 프로세스라고 합니다. 프로세스는 고유의 번호인 프로세스 번호(PID)를 가지고 있습니다.

### 프로세스의 종류

<p align="center"><img src="../../images/시스템프로그래밍및보안/5) 파이프, 전면 처리와 후면 처리, 프로세스-Untitled 1.png"></p>

- 데몬 : UNIX에서 서버를 일컫는 말
- 서버 : 요청이 와야만 응답하는 프로그램(수동적인 프로그램)

### 프로세스 확인

```bash
$ ps
```

<p align="center"><img src="../../images/시스템프로그래밍및보안/5) 파이프, 전면 처리와 후면 처리, 프로세스-Untitled 2.png"></p>

ps 명령어를 통해 현재 프로세스를 확인할 수 있습니다.

- tty : 실행중인 단말기(터미널) 정보

**옵션**

- -a : 모든 사용자의 프로세스 출력
- -u : 프로세스에 대한 자세한 정보를 출력
- -x : 제어 터미널을 갖지 않게된 프로세스 출력
- -e : 모든 사용자 프로세스 정보 출력
- -f : 프로세스에 대한 자세한 정보 출력

ps는 시스템에 따라 옵션의 종류와 사용 방법의 차이가 큽니다. -aux의 경우 BSD 유닉스에서, -ef는 시스템 V에서 사용할 수 있습니다. (ubuntu는 둘 다 가능)

### 프로세스 검색

ps와 grep을 파이프하여 검색할 수도 있지만 이 둘을 합친 pgrep을 활용하면 프로세스를 쉽게 검색할 수 있습니다.

```bash
$ pgrep [option] [pattern] # ps -ef | grep [pattern]과 동일
```

**옵션**

- -l : PID와 함께 프로세스의 이름을 출력
- -f : 명령어의 경로도 출력
- -n : 패턴과 일치하는 가장 최근 프로세스만 출력
- -x : 패턴과 정확하게 일치되는 프로세스만 출력

### 프로그램 종료

kill 명령어를 통해 프로세스를 강제로 종료할 수 있습니다.

```bash
$ kill [signal] PID
$ kill %작업번호
```

<p align="center"><img src="../../images/시스템프로그래밍및보안/5) 파이프, 전면 처리와 후면 처리, 프로세스-Untitled 3.png"></p>

시그널을 지정하여 kill의 종류를 고를 수 있습니다. default는 15로서 프로세스에게 무시할 수 있는 강제 종료 신호를 보냅니다.

### exit

exit은 현재 쉘에서 종료(로그아웃)한 후 종료 코드를 부모 프로세스에게 전달하는 명령어입니다.

```bash
$ exit [종료코드]
```

만약, 여러 개의 쉘을 중첩하여 사용할 경우 가장 최근에 실행한 쉘부터 exit합니다.