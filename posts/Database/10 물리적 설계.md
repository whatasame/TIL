# 10. 물리적 설계

## 파일 구성 방법

### 레코드 표현 방법

- 고정 길이 레코드
    - 레코드 삭제?
        - 한 칸씩 당기기
        - 마지막 레코드를 삭제한 레코드 위치로
        - Free list
- 가변 길이 레코드
    - Null-value bitmap
        
        → 가변 길이 레코드 블록 구조
        

### 레코드 저장 방법

- Heap
- 순차 파일 구성
    - Array vs. LinkedList?
    - 재구성을 하는 이유?
- 해싱
- 다중-테이블 클러스터링
    - 장단점?
    - 단점 해결 방법?

## 접근 방법 설계

### 접근 방법

- 인덱스
    - 유일 인덱스
    - 보조 인덱스
- 해싱
- Clustering
- Clustering Index
    - 하나의 테이블에는 하나의 _____만 존재?

## 유일 인덱스

### B Tree

- 속성 6개
    - 각 노드는 최대 ___개의 포인터를 가질 수 있다.
    - 일반 노드(not root, leaf)는 적어도 ____ 개의 자식을 가져야한다.
    - root는 적어도 ___ 개의 자식을 가져야한다.
    - 모든 ____ 들은 같은 레벨에 위치한다.
    - leaf가 아닌 노드가 k개의 자식을 가질 경우 키의 개수는 __개다.
    - 각 노드에서 키는 ____대로 정렬되어야 한다.
- 하나의 노드 = 하나의 ____

### B* Tree

- B Tree와 차이점
    - 루트를 제외한 모든 노드들은 적어도 _______ 개의 포인터를 가져야한다.
        - B Tree → ____ split
        - B* Tree → ____ split
- B* Tree를 쓰는 이유
    
    

### B$^{+}$ Tree

- _____ set와 _____ set으로 구성되어 있다.
- _____ set의 노드는 자식 노드 주소 정보만 가지고 있다.
- _____ set의 노드는 레코드 주소 정보만 가지고 있다.
- _____ set의 노드는 서로 연결 리스트로 이어져있다.
- 삭제는 _____ set에서만 일어난다.

### B family 정리

- B보다는 B+이 노드를 많이 담을 수 있어서 좋다
    - 그런데, 트리의 깊이가 깊어지면 중간에 찾을 수 있는 B가 유리한 것 아닌가?
- B*은 I/O가 심각하게 느릴 때 Tree depth를 줄이기 위해 사용

## 보조 인덱스

후보 키가 아닌 속성을 검색 키로 사용하면 여러 레코드가 나온다 → 유일 인덱스 사용 불가 

→ 이 때 사용하는 인덱스

### value에 저장하는 값

- 데이터 레코드의 주소
    - 장단점
- 주 키
    - 장단점

### 역 인덱스

- 보조 인덱스를 ____ 구조로 구현
- 단점 : __ 길이 레코드 사용 → ㄴㅂ ㄷㅍㅎ 발생

### 다중 리스트 파일

- 장점 : __ 길이 레코드 사용
- 단점 : ___ 횟수 증가