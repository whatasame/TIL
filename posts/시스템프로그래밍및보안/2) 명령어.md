# 2) 명령어

Linux의 명령어를 알아보도록 하겠습니다. 명령어 중에서 Windows나 Mac에서 동일한 기능을 하지만 이름이 다른 경우, Linux에만 있는 명령어들에 대해 잘 생각해 봅시다.

> 알아두면 좋은 것
> 

0개 이상 (zero or more), + : 1개 이상 (one or more)

^C (강제 종료), ^D (정상 종료), ^Z (일시 중지)

-v : 명령어 실행 결과 출력(verbose)

## 정보 출력 명령어

### date

현재 날짜, 시간을 출력합니다.

### hostname

시스템 관리자가 부여한 호스트 이름을 확인합니다.

### uname

운영체제 정보를 출력합니다..

### who

현재 리눅스에 접속해 있는 유저들의 목록을 출력합니다.

### clear

화면을 정리하고 첫째줄 프롬포트를 표시합니다.

### passwd

암호를 변경합니다.

### man

메뉴얼을 출력합니다.

## 디렉토리 관련 명령어

### pwd

```bash
$ pwd
```

현재 작업 디렉토리의 절대 경로명을 출력합니다.

### cd

```bash
$ cd 디렉토리
```

지정한 디렉토리로 이동합니다. **디렉토리를 지정하지 않으면 홈 디렉토리로 이동합니다.**

### which

```bash
$ which 명령어
```

명령어의 절대 경로를 표시합니다.

### mkdir

```bash
$ mkdir [option] 디렉토리_이름
```

새로운 디렉토리를 생성합니다.

**옵션**

- -p : 계층 구조를 갖는 디렉토리를 생성할 때 중간 디렉토리가 없는 경우 자동으로 생성

### rmdir

```bash
rmdir 디렉토리+
```

비어있는 디렉토리를 삭제합니다.

<aside>
💡 rmdir 명령어로 비어있지 않은 디렉토리는 삭제할 수 없습니다. rm -r 명령어를 통해 디렉토리와 디렉토리 안에 있는 파일을 삭제할 수 있습니다. Linux에서 디렉토리도 파일로 관리하기 때문에 가능한 작업입니다.
왜 이렇게 불편하게 만들었을까요? Linux에는 휴지통이 없기 때문에 여러 파일들이 속한 디렉토리를 함부로 삭제하지 못하게 한 것입니다.

</aside>

### ls

```bash
$ ls [option] 디렉토리* 파일*
```

디렉토리의 파일 리스트를 출력합니다. 

디렉토리를 지정하지 않은 경우 현재 디렉토리의 파일 리스트를 출력합니다.

파일을 지정한 경우 해당 파일만 출력합니다.

**옵션**

- -s : 파일 크기를 KB단위로 표시(size)
- -a : .로 시작하는 숨김 파일을 표시(all)
- -l : 파일 정보를 자세히 표시(long)
    
    <p align="center"><img src="../../images/시스템프로그래밍및보안/2) 명령어-Untitled.png"></p>
    
    - ① : 블록에 할당된 파일 크기
    - ② : 파일 종류
    - ③ : 파일 접근 권한
    - ④ : 파일 링크 수
    - ⑤ : 소유자, 사용자 ID
    - ⑥ : 그룹 정보, 그룹 ID
    - ⑦ : 파일의 실제 크기 **cf. ①**
    - ⑧ : 최종 수정 시간(ls 명령어 옵션에 관련 옵션이 없는 경우 default: mtime)
    - ⑨ : 파일 이름
- -h : 사람이 읽기 쉽게 표시(human)
- -F : 파일의 종류를 이름 뒤에 기호로 표시하여 출력
    
    → 실행 파일 *, 디렉토리 /, 소켓 =, 링크@
    

<aside>
💡 Windows와 달리 Linux에는 확장자 개념이 없습니다. Linux에서 확장자를 붙이는 이유는 사용자의 구분을 돕기 위함입니다.

</aside>

- -R : 모든 하위 디렉토리에 대해서도 동일하게 명령어 수행

## 파일 출력 명령어

<aside>
💡 파일 출력 명령어에서 파일을 지정하지 않으면 키보드로 입력한 내용에 대해 명령어를 수행합니다.

</aside>

### cat

```bash
$ cat 파일
```

파일의 내용을 출력합니다.

**옵션**

- -n : 출력 내용에 줄 번호를 표시합니다.

<aside>
💡 사실 cat은 파일 읽기뿐만 아니라 파일 결합, 파일 편집 등 많은 기능을 수행하는 명령어입니다.

</aside>

**cat의 다양한 용도**

- 파일 출력
    
    ```bash
    # 파일 A의 내용을 출력합니다.
    $ cat A [noting]
    ```
    
- 파일 합치기
    
    ```bash
    # 파일 A의 내용과 파일 B의 내용을 결합하여 출력합니다.
    $ cat A B
    ```
    
- 파일 합쳐 새로운 파일 만들기
    
    ```bash
    # 파일 A의 내용과 파일 B의 내용을 결합하여 파일 C를 생성합니다.
    cat A B > C
    ```
    
- 키보드로 입력받아 파일 저장
    
    ```bash
    # 키보드로 입력받은 내용을 파일 A에 저장합니다.
    $ cat > A
    ```
    
    - 파일 A에 내용이 있는 경우 해당 내용은 없어지고 입력한 내용만 남습니다.
    - ^D (Ctrl + D)를 눌러 입력을 멈출 수 있습니다.

### head, tail

```bash
$ tail [option] 파일
```

head는 파일 내용의 앞부분을, tail은 파일 내용의 뒷부분을 출력합니다.

******옵션******

- -n # : #개의 줄을 출력합니다.

### wc

```bash
$ wc [option] 파일
```

파일의 줄, 단어, 문자의 개수를 세서 출력합니다

******옵션******

- -l : 줄 수를 출력합니다.
- -w : 단어 수를 출력합니다.
- -c : 문자 수를 출력합니다.

## 파일 관련 명령어

### touch

```bash
$ touch 파일이름+
```

파일의 날짜와 시간을 수정하는 명령어입니다. 그러나 대부분 0바이트 파일을 생성하는 목적으로 사용됩니다. 없는 파일을 수정하려고 하면 0바이트 파일을 생성해주기 때문입니다. 

### cp

```bash
$ cp [option] 파일+ 디렉토리
```

파일을 지정한 디렉토리로 복사하는 명령어입니다.

**옵션**

- -r : 하위 디렉토리를 포함한 디렉토리 전체를 복사합니다.
- -i : 복사하려는 파일의 이름과 같은 이름을 갖는 파일이 있는 경우 덮어쓸 지 물어봅니다. (interact)

<aside>
💡 -i 옵션을 넣지 않으면 동일한 이름을 갖는 파일을 덮어쓰기 하여 예상치 못한 문제가 발생할 수 있음

</aside>

### mv

```bash
$ mv [option] 파일+ 디렉토리 # 파일을 지정한 디렉토리로 이동
$ mv [option] A B # 파일 A의 이름을 B로 수정
```

파일을 이동하는 명령어입니다. 파일의 이름을 수정할 때 사용할 수도 있습니다.

Linux에서 디렉토리는 파일이므로 디렉토리의 이름을 바꿀 때도 사용합니다.

**옵션**

- -r : 하위 디렉토리를 포함한 디렉토리 전체를 복사합니다.
- -i : 이동하려는 파일의 이름과 같은 이름을 갖는 파일이 있는 경우 덮어쓸 지 물어봅니다. (interact)

<aside>
💡 -i 옵션을 넣지 않으면 동일한 이름을 갖는 파일을 덮어쓰기 하여 예상치 못한 문제가 발생할 수 있음

</aside>

### rm

```bash
$ rm [option] 파일+
```

파일을 삭제하는 명령어입니다. 

**옵션**

- -r : 하위 디렉토리를 포함한 디렉토리 전체를 삭제합니다.
- -i : 파일을 삭제하기 전에 파일을 삭제할 것인지 물어봅니다.(interact)

## 유틸리티 명령어

### grep

```bash
$ grep pattern 파일*
```

grep 명령어는 대상으로 지정된 패턴의 문자열을 검색하고 해당 **문자열을 포함하는 줄을 출력**합니다.

정규표현식(regex)를 사용할 수 있습니다.

```bash
$ grep 'regex' 파일*
```

grep은 개행 문자가 나올 때까지 패턴을 검색하므로 정규 표현식에 따라 여러 단어가 선택될 수 있습니다. 따라서, 단어 단위로 패턴을 검사하고싶으면 -w 옵션을 반드시 넣어야합니다.

**옵션**

- -i : 대소문자를 무시하고 검색
- -l : 파일 내용에 해당 패턴이 있는 파일의 이름을 출력
- -n : 각 줄의 줄번호도 함께 출력
- -v : 패턴을 포함하지 않는 줄을 출력
- -c : 패턴과 일치하는 줄 수를 출력
- -w : 패턴이 하나의 단어로 된 것만 검색
- -r : 하위 디렉토리 탐색
- -R : 심볼릭 링크를 따라가며 모든 하위 디렉토리 검색
- -o : 매치되는 문자열만 표시

파이프와 grep을 활용하면 명령어의 결과에서 원하는 값만 확인할 수 있습니다.

```bash
$ ls -l | grep chang
$ ps -ef | grep chang
```

### sort

sort 명령어는 정렬 필드를 기준으로 줄 단위 오름차순으로 정렬하여 출력합니다.

필드는 띄어쓰기를 기준으로 나뉩니다. 또한 필드 번호는 0부터 시작하며 필드 번호를 지정하지 않을 시 첫 번째 필드(0번 필드)가 정렬 필드가 됩니다. 

- 사용법
    
    $ sort [-option] 파일*
    
- 정렬 필드 지정 방법
    - -k 필드 번호
        
        k번째 필드를 기준으로 정렬
        
        이 옵션에서 필드 번호는 1부터 시작
        
        e.g. -k 5 → 5번째 필드(4번 필드)를 기준으로 정렬
        
    - +시작 필드 -종료 필드
        
        시작 필드 ~ 종료 필드-1까지의 필드들을 기준으로 정렬
        
        이 옵션에서 필드 번호는 0부터 시작
        
        e.g. +2 -3 → 2번 필드부터 (3-1)번 필드까지 기준으로 정렬. 즉, 2번 필드(3번째 필드)를 기준으로 정렬
        
- 옵션
    
    -r : reverse. 내림차순 정렬
    
    -t 문자 : 지정한 문자를 필드 구분자로 사용(default : \s)
    
    -b : 앞에 붙는 공백은 무시
    
    -c : 정렬이 되지 않은 상태로 출력
    
    -d : 숫자, 문자, 공백만 비교하여 사전식 순서로 정렬
    
    -f : 대소문자를 구분하지 않고 정렬 
    
    -n : 숫자 문자열의 숫자 값에 따라 비교하여 정렬
    
    e.g. 49와 100에 대하여..
    
    default : 문자열로는 100이 49보다 앞서므로 100, 49로 오름차순
    
    -n : 숫자로는 49가 100보다 앞서므로 49, 100으로 오름차순
    

### split

split 명령어는 하나의 파일을 일정한 크기의 여러 개 작은 파일로 분할하는 명령어입니다.

기본 값으론 1000줄씩 분할하여 xaa, xab, … 형태의 파일명으로 저장합니다.

- 사용법
    
    $ split [-option] 입력파일 [출력파일]
    
    e.g. $ split -l 10 you.txt → you.txt 파일을 10줄 단위로 분할
    

### cat

cat 명령어는 여러 개의 파일을 하나의 파일로 합치는 역할도 합니다.

- 사용법
    
    $ cat 파일1 파일2 > 파일3
    

### paste

paste 명령어는 여러 파일에서 각 파일의 줄 단위로 합병하여 하나의 파일로 만들어 주는 명령어입니다.

cat 명령어는 파일 하나의 내용 전체 뒤에 다른 파일의 내용이 이어지는 반면, paste는 각 파일에서 한 줄씩 읽어 하나의 파일에 저장할 수 있습니다.

- 사용법
    
    $ paste [-option] 파일*
    
- 옵션
    
    -s : 각 파일의 값을 수직으로 읽어 수평으로 저장
    
    -d 구분문자 : 각 줄의 사이에 구분하는 문자를 지정
    

참고할만한 글 : [http://hyeonjae-blog.logdown.com/posts/654302](http://hyeonjae-blog.logdown.com/posts/654302)

### cmp

cmp 명령어는 두 파일이 같은 지 비교하는 명령어입니다. 만약 두 파일의 내용이 같다면 아무것도 출력하지 않지만, 두 파일의 내용이 같지 않다면 서로 다른 위치를 출력합니다.

파일의 수정 여부를 알 수 있으므로 보안 관련 설정 파일 검토 용으로 사용 가능합니다.

- 사용법
    
    $ cmp 파일1 파일2
    
- 예제
    
    $ cmp you.txt me.txt
    
    결과) you.txt me.txt differ : byte 340, line 10
    
    → 두 파일의 10번째 줄 340번째부터 문자가 다름
    

### diff

diff 명령어는 두 파일을 줄 단위로 비교하여 그 차이를 출력합니다.

- 사용법
    
    $ diff 파일1 파일2
    
- 예제
    
    $ diff you.txt me.txt
    
    결과) 9 a 10, 13
    
    → 첫 번째 파일의 9번째 줄 뒤에 두 번째 파일의 10~13번째 줄 내용을 추가하면 두 파일이 같아진다는 뜻입니다.
    
- 출력 결과 유형
    - 추가(a)
        
        n1 a n3, n4 
        
        → 첫 번째 파일의 n1번째 줄 뒤에 두 번째 파일의 n3부터 n4까지 줄을 추가하면 두 파일이 같아진다.
        
    - 삭제(d)
        
        n1, n2 d n3
        
        → 첫 번째 파일의 n1부터 n2번째까지 줄을 삭제하면 두 번째 파일의 줄 n3 이후와 서로 같아진다.
        
        → 두 파일의 앞부분이 서로 같은 상황에서 첫 번째 파일의 n1부터 n2까지 내용이 다르고 n3부터 같으니 첫 번째 파일의 n1~n2를 삭제하면 두 번째 파일의 n3와 같아진다는 뜻
        
    - 변경(c)
        
        n1, n2 c n3, n4
        
        → 첫 번째 파일의 n1부터 n2번째 줄을 두 번째 파일의 n3부터 n4까지 줄로 변경하면 두 파일이 같아진다.
        
- 옵션
    
    -i : 대소문자를 무시하고 비교
    

참고하면 좋은 글 : [https://websecurity.tistory.com/105](https://websecurity.tistory.com/105)

### ln

링크란 기존의 파일에 또 하나의 새로운 이름 혹은 경로를 부여하는 것을 말합니다. 링크는 윈도우의 바로가기와 유사한데요. 바로가기만 존재하는 윈도우와 달리 링크는 하드 링크, 심볼릭 링크 두 종류가 있습니다.

> 하드 링크
> 

하드 링크를 이해하기 전에 파일이 저장되는 방법부터 알아보도록 하겠습니다.

파일은 디스크의 블럭이라는 단위로 저장됩니다. 파일의 크기가 크면 하나의 파일이 여러개의 블럭에 저장됩니다. 파일이 저장되어있는 블럭들을 가리키는 포인터들이 있는데요, i-node는 이러한 포인터들이 저장된 블럭을 말합니다. 

즉, i-node는 파일이라는 데이터가 저장되어있는 위치 데이터(포인터)를 가지고 있습니다. 이렇게 데이터의 데이터를 메타 데이터라고 합니다. 사실 i-node는 블럭 포인터 외 파일 권한, 링크 수, 사용자 명 등 다양한 정보를 가지고 있지만 여기서는 다루지 않겠습니다.

<p align="center"><img src="../../images/시스템프로그래밍및보안/2) 명령어-Untitled 1.png"></p>

UNIX 환경에서 모든 파일은 개별의 i-node를 가지고 있습니다. ls 명령어의 -i 옵션을 통해 파일의 i-node를 확인할 수 있습니다.

하드 링크는 기존 파일을 가리키는 i-node를 복사하여 생성한 직접적인 포인터 파일입니다. 디스크에 저장된 파일에 대 i-node를 원본 파일과 하드 링크 파일이 모두 가리키고 있습니다. 윈도우에는 없는 개념입니다.

<p align="center"><img src="../../images/시스템프로그래밍및보안/2) 명령어-Untitled 2.png"></p>

> 심볼릭 링크
> 

심볼릭 링크는 새로운 i-node를 생성하여 원본 파일의 i-node를 가리키는 간접적인 포인터 파일입니다. 원본 파일의 경로명을 통해 원본 파일에 대한 포인터 역할을 수행합니다. 윈도우의 바로가기와 유사합니다.

<p align="center"><img src="../../images/시스템프로그래밍및보안/2) 명령어-Untitled 3.png"></p>

ln 명령어는 **기본적으로 하드 링크**를 생성하며 **-s 옵션을 추가함으로써 심볼릭 링크**를 생성할 수 있습니다.

- 사용법
    
    $ ln [-option] 파일1 파일2
    
    → 파일1에 대한 새로운 링크로 파일2를 생성
    
    $ ln [-option] 파일1 디렉토리
    
    → 파일1에 대한 새로운 링크를 지정된 디렉토리에 **같은 이름**으로 생성
    

> 복사 vs 링크
> 

복사와 링크, 둘 다 기존의 파일에서 새로운 파일을 생성한다는 것은 동일합니다. 그러나 둘은 성격이 완전 다릅니다. 그 차이를 표로 살펴보겠습니다.

| 복사 | 링크 |
| --- | --- |
| 개별의 별도 파일 생성 | 이름만 다르고 내용은 동일 |
| 둘 중 하나를 수정해도 다른 파일에 영향을 주지 않음 | 둘 중 하나를 수정하면 다른 파일도 똑같이 수정됨 |
| 같은 파일을 별도로 수정하여 작업할 때 사용 | 파일을 공동으로 관리할 때 사용 |

> 하드 링크 vs 심볼릭 링크
> 

| 하드 링크 | 심볼릭 링크 |
| --- | --- |
| 원본을 지우면 하드 링크가 원본의 역할을 대신함 | 원본을 지우면 심볼릭 링크로 데이터에 접근 불가능 |
| 디렉토리에 대한 하드 링크는 슈퍼 유저만 가능 | 디렉토리에 대한 심볼릭 링크는 일반 사용자도 가능 |
| 물리적으로 다른 파일 시스템 간의 하드 링크 불가 | 물리적으로 다른 파일 시스템 간의 심볼릭 링크 가능 |