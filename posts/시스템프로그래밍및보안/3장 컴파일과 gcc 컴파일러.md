# 3장 컴파일과 gcc 컴파일러

✅ [https://bradbury.tistory.com/226의](https://bradbury.tistory.com/226%EC%9D%98) 내용을 바탕으로 제가 공부한 내용을 추가하였습니다.

## 컴파일

컴파일은 인간이 이해할 수 있는 고급 언어로 작성된 소스 코드를 CPU가 이해할 수 있는 기계어로 변환하는 작업을 말합니다. 컴퓨터는 0과 1로 이루어진 기계어만 이해할 수 있기 때문에 우리가 작성한 소스코드를 실행시키기 위해 컴파일 과정이 반드시 필요합니다. 

<p align="center"><img src="../../images/시스템프로그래밍및보안/3장 컴파일과 gcc 컴파일러-Untitled.png"></p>

컴파일 과정을 도식화하면 위 그림과 같습니다. 컴파일은 전처리 과정 → 작은 의미의 컴파일 과정→ 어셈블리 과정 → 링킹 과정으로 나누어집니다.

### 전처리 과정

컴파일 대상에는 소스 코드 뿐만 아니라 소스 코드에 필요한 변수나 함수가 정의되어있는 헤더 파일도 해당합니다.

<p align="center"><img src="../../images/시스템프로그래밍및보안/3장 컴파일과 gcc 컴파일러-Untitled 1.png"></p>

전처리 과정은 전처리기를 통해 소스 코드와 헤더 파일을 전처리된 소스코드로 변환하는 과정입니다. 전처리 과정에서 수행되는 대표적인 작업은 아래와 같습니다.

- 주석 제거
    
    사람의 이해를 돕기 위해 작성된 주석을 소스 코드에서 제거합니다.
    
- 헤더 파일 삽입
    
    #include 지시문을 만나면 해당 헤더 파일을 찾아 헤더 파일의 내용을 모두 복사하여 소스 코드에 삽입합니다. 즉, 헤더 파일은 다른 파일과 함께 사용되는 것이 아닌 전처리 과정에서 소스 코드와 합쳐집니다. 
    
    헤더 파일에 함수 원형이 선언되어있다면 추후 링킹 과정에서 실제로 함수가 정의되어 있는 오브젝트 파일과 결합합니다.
    
    <aside>
    💡 헤더 파일에는 함수의 바디가 정의되어 있으면 안됩니다. 즉, 헤더 파일에는 함수는 프로토타입 형태로만 존재합니다.
    
    </aside>
    
    <aside>
    💡 사용자가 만든 헤더 파일의 함수 바디는 사용자가 작성한 소스 코드에 있을 것이고 컴파일 과정을 통해 오브젝트 파일로 변환된 후 연결됩니다. 라이브러리 헤더 파일의 함수 바디는 처음부터 오브젝트 파일의 형태로 저장되어있습니다.
    
    </aside>
    
- 매크로 치환 및 적용
    
    #define 지시문에 정의된 매크로를 저장하고 같은 문자열을 만나면 #define 된 내용으로 치환합니다. 다시 말해 매크로 이름을 찾아 정의한 값으로 모두 변경합니다.
    

### 작은 의미의 컴파일 과정

컴파일 과정에는 아이러니하게도 컴파일 과정이 있습니다. 전체 컴파일 과정을 컴파일이라고 부르고 컴파일 과정 안에 있는 컴파일 과정을 작은 의미의 컴파일 과정이라고 하겠습니다.

<p align="center"><img src="../../images/시스템프로그래밍및보안/3장 컴파일과 gcc 컴파일러-Untitled 2.png"></p>

컴파일 과정은 컴파일러를 통해 전처리된 소스 코드 파일을 어셈블리어 파일로 변환하는 과정입니다. 이 과정에서 우리가 컴파일 에러라고 부르는 언어의 문법 검사가 이루어집니다.

또한 Static 영역의 메모리 할당도 수행합니다.

### 어셈블리 과정

CPU는 0과 1의 조합으로 이루어진 명령어들을 가지고 있습니다. 이러한 명령어는 CPU에 따라 하는 역할이 같아도 서로 다른 형태를 가지고 있는데 이를 ISA(Instruction Set Architecture)라고 합니다. 어셈블리어는 이러한 명령어를 사람이 이해할 수 있도록 부호화한 것으로 CPU 명령어와 1대1로 매칭됩니다. 따라서 어셈블리어는 고급언어와 기계어 사이의 중간 언어라고 할 수 있습니다.

<p align="center"><img src="../../images/시스템프로그래밍및보안/3장 컴파일과 gcc 컴파일러-Untitled 3.png"></p>

어셈블리 과정은 어셈블러를 통해 어셈블리어 파일을 오브젝트 파일로 변환하는 과정입니다. 결론부터 말하자면 사람이 마지막으로 읽을 수 있는 언어인 어셈블리어가 0과 1로 이루어진 기계어로 바뀝니다.

<aside>
💡 오브젝트 파일이란 어셈블리 과정이 끝나 기계어로 변환된 파일을 말합니다.

</aside>

어셈블리 과정을 통해 만들어진 오브젝트 파일은 기계어로 되어있기 때문에 컴퓨터가 이해할 수 있습니다. 그러나 오브젝트 파일만 가지곤 컴퓨터가 실행할 수 없습니다. 전처리 과정에서 추가된 헤더 파일의 함수와 같이 바디가 없는 함수가 있기 때문입니다. 따라서 해당 함수의 바디가 존재하는 오브젝트 파일과 연결해주는 작업이 필요합니다.

### 링킹 과정

소스 코드 파일이 여러 개 있을 때 어셈블리 과정까지 진행이 되면 각각의 오브젝트 파일이 생깁니다. 라이브러리나 헤더 파일을 통해 오브젝트 밖의 값을 참조할 경우 개별 오브젝트에선 구현되어있지 않기 때문에 실행할 수 없습니다. 이렇게 오브젝트 밖의 참조를 이어주는 작업을 링크라고 합니다. 

<p align="center"><img src="../../images/시스템프로그래밍및보안/3장 컴파일과 gcc 컴파일러-Untitled 4.png"></p>

링크는 여러 개로 분리된 소스 코드를 컴파일 한 후 생성된 각각의 오브젝트 파일과 필요한 라이브러리를 연결하는 것을 말합니다. 링킹은 여러 오브젝트 파일과 라이브러리를 링크를 함으로써 **최종적으로 실행가능한 하나의 파일**을 만드는 작업입니다.

링킹 과정까지 마치면 하나의 실행 파일이 만들어지며 컴파일이 끝납니다. 이 파일을 실행하면 실행 파일의 내용이 운영체제의 Loader를 통해 메모리에 적재되고 CPU가 이것을 읽고 쓰며 프로그램이 동작합니다. 

## gcc 컴파일러

gcc는 GNU Compiler Collection의 약자로서 공개 소프트웨어 프로젝트인 GNU Project에서 제작된 C/C++용 컴파일러입니다.

**사용법**

```bash
$ gcc [-option] 파일
```

옵션을 주지않고 컴파일을 할 경우 기본 실행 파일인 a.out이 생성됩니다.

**옵션**

- -o : 컴파일 결과로 만들어진 실행 파일의 이름을 지정합니다.
- -c : 컴파일 전체를 수행하지않고 어셈블리 과정까지만 수행하여 오브젝트 파일을 생성합니다.
- -S : 컴파일 전체를 수행하지않고 작은 의미의 컴파일만 수행하여 어셈블리 코드 파일을 생성합니다.
- -save-temps : 컴파일 과정에서 사용되는 파일 전체(소스 코드.c, 전처리된 소스코드.i, 어셈블리 코드.s, 오브젝트 파일.o, 실행 파일 a.out)를 저장합니다.
    
    <p align="center"><img src="../../images/시스템프로그래밍및보안/3장 컴파일과 gcc 컴파일러-Untitled 5.png"></p>
    
    <aside>
    💡 각각의 파일을 메모장으로 열어보자
    
    </aside>
    
- -O : 컴파일 최적화를 수행하여 **실행 시간을 단축**합니다.
    - -O0 : 최적화를 수행하지 않습니다.
    - -O1, O2  : 최적화를 수행합니다. (**default : O2**)
    - -O3 : 가장 높은 수준의 최적화를 수행합니다. 프로그램이 의도대로 실행되지 않을 수 있습니다.
    - -Os : **실행 파일 크기를 기준**으로 최적화합니다.
- -D : 매크로 값을 지정합니다.
    
    ```c
    #include <stdio.h>
    int main(void)
    {
        printf("-D[NUM] = %d\n", NUM);
        return 0;
    }
    ```
    
    ```bash
    $ gcc -DNUM=5 hello.c
    $ ./a.out
    -D[NUM] = 5
    ```
    
    NUM을 정의하지 않았지만 D 옵션으로 NUM 값을 지정할 수 있습니다. 이러한 것을 심볼 정의(-DVALUE option)라고 합니다. 심볼 정의를 활용하면 정상적으로 작동하는 프로그램 내에 분기점을 두어 디버깅 모드와 같은 개발자 모드를 구현할 수 있습니다.