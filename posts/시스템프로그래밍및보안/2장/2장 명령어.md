# 2장 명령어

# 유틸리티

## 파일 관련 유틸리티

### touch

내용이 없는 파일을 생성합니다.

- 사용법
    
    touch 파일이름
    

### grep

grep 명령어는 대상으로 지정된 패턴의 문자열을 검색하고 해당 **문자열을 포함하는 줄을 출력**합니다.

- 사용법
    
    $ grep pattern 파일*
    
- 옵션
    
    -i : 대소문자를 무시하고 검색
    
    -l : 파일 내용에 해당 패턴이 있는 파일의 이름을 출력
    
    -n : 각 줄의 줄번호도 함께 출력
    
    -v : 패턴을 포함하지 않는 줄을 출력
    
    -c : 패턴과 일치하는 줄 수를 출력
    
    -w : 패턴이 하나의 단어로 된 것만 검색
    
    -r : 하위 디렉토리 탐색
    
    -R : 심볼릭 링크를 따라가며 모든 하위 디렉토리 검색
    
    -o : 매치되는 문자열만 표시
    
- grep에선 정규표현식(regex)를 사용할 수 있습니다.
    
    사용법 : $ grep ‘regex’ 파일*
    
    grep은 개행 문자가 나올 때까지 패턴을 검색하므로 정규 표현식에 따라 여러 단어가 선택될 수 있습니다. 따라서, 단어 단위로 패턴을 검사하고싶으면 -w 옵션을 반드시 넣어야합니다.
    
- 파이프와 grep을 활용하면 다른 명령어의 결과에서 원하는 값을 검색할 수 있습니다.
    
    $ ls -l | grep chang
    
    $ ps -ef | grep chang
    

### sort

sort 명령어는 정렬 필드를 기준으로 줄 단위 오름차순으로 정렬하여 출력합니다.

필드는 띄어쓰기를 기준으로 나뉩니다. 또한 필드 번호는 0부터 시작하며 필드 번호를 지정하지 않을 시 첫 번째 필드(0번 필드)가 정렬 필드가 됩니다. 

- 사용법
    
    $ sort [-option] 파일*
    
- 정렬 필드 지정 방법
    - -k 필드 번호
        
        k번째 필드를 기준으로 정렬
        
        이 옵션에서 필드 번호는 1부터 시작
        
        e.g. -k 5 → 5번째 필드(4번 필드)를 기준으로 정렬
        
    - +시작 필드 -종료 필드
        
        시작 필드 ~ 종료 필드-1까지의 필드들을 기준으로 정렬
        
        이 옵션에서 필드 번호는 0부터 시작
        
        e.g. +2 -3 → 2번 필드부터 (3-1)번 필드까지 기준으로 정렬. 즉, 2번 필드(3번째 필드)를 기준으로 정렬
        
- 옵션
    
    -r : reverse. 내림차순 정렬
    
    -t 문자 : 지정한 문자를 필드 구분자로 사용(default : \s)
    
    -b : 앞에 붙는 공백은 무시
    
    -c : 정렬이 되지 않은 상태로 출력
    
    -d : 숫자, 문자, 공백만 비교하여 사전식 순서로 정렬
    
    -f : 대소문자를 구분하지 않고 정렬 
    
    -n : 숫자 문자열의 숫자 값에 따라 비교하여 정렬
    
    e.g. 49와 100에 대하여..
    
    default : 문자열로는 100이 49보다 앞서므로 100, 49로 오름차순
    
    -n : 숫자로는 49가 100보다 앞서므로 49, 100으로 오름차순
    

### split

split 명령어는 하나의 파일을 일정한 크기의 여러 개 작은 파일로 분할하는 명령어입니다.

기본 값으론 1000줄씩 분할하여 xaa, xab, … 형태의 파일명으로 저장합니다.

- 사용법
    
    $ split [-option] 입력파일 [출력파일]
    
    e.g. $ split -l 10 you.txt → you.txt 파일을 10줄 단위로 분할
    

### cat

cat 명령어는 여러 개의 파일을 하나의 파일로 합치는 역할도 합니다.

- 사용법
    
    $ cat 파일1 파일2 > 파일3
    

### paste

paste 명령어는 여러 파일에서 각 파일의 줄 단위로 합병하여 하나의 파일로 만들어 주는 명령어입니다.

cat 명령어는 파일 하나의 내용 전체 뒤에 다른 파일의 내용이 이어지는 반면, paste는 각 파일에서 한 줄씩 읽어 하나의 파일에 저장할 수 있습니다.

- 사용법
    
    $ paste [-option] 파일*
    
- 옵션
    
    -s : 각 파일의 값을 수직으로 읽어 수평으로 저장
    
    -d 구분문자 : 각 줄의 사이에 구분하는 문자를 지정
    

참고할만한 글 : [http://hyeonjae-blog.logdown.com/posts/654302](http://hyeonjae-blog.logdown.com/posts/654302)

### cmp

cmp 명령어는 두 파일이 같은 지 비교하는 명령어입니다. 만약 두 파일의 내용이 같다면 아무것도 출력하지 않지만, 두 파일의 내용이 같지 않다면 서로 다른 위치를 출력합니다.

파일의 수정 여부를 알 수 있으므로 보안 관련 설정 파일 검토 용으로 사용 가능합니다.

- 사용법
    
    $ cmp 파일1 파일2
    
- 예제
    
    $ cmp you.txt me.txt
    
    결과) you.txt me.txt differ : byte 340, line 10
    
    → 두 파일의 10번째 줄 340번째부터 문자가 다름
    

### diff

diff 명령어는 두 파일을 줄 단위로 비교하여 그 차이를 출력합니다.

- 사용법
    
    $ diff 파일1 파일2
    
- 예제
    
    $ diff you.txt me.txt
    
    결과) 9 a 10, 13
    
    → 첫 번째 파일의 9번째 줄 뒤에 두 번째 파일의 10~13번째 줄 내용을 추가하면 두 파일이 같아진다는 뜻입니다.
    
- 출력 결과 유형
    - 추가(a)
        
        n1 a n3, n4 
        
        → 첫 번째 파일의 n1번째 줄 뒤에 두 번째 파일의 n3부터 n4까지 줄을 추가하면 두 파일이 같아진다.
        
    - 삭제(d)
        
        n1, n2 d n3
        
        → 첫 번째 파일의 n1부터 n2번째까지 줄을 삭제하면 두 번째 파일의 줄 n3 이후와 서로 같아진다.
        
        → 두 파일의 앞부분이 서로 같은 상황에서 첫 번째 파일의 n1부터 n2까지 내용이 다르고 n3부터 같으니 첫 번째 파일의 n1~n2를 삭제하면 두 번째 파일의 n3와 같아진다는 뜻
        
    - 변경(c)
        
        n1, n2 c n3, n4
        
        → 첫 번째 파일의 n1부터 n2번째 줄을 두 번째 파일의 n3부터 n4까지 줄로 변경하면 두 파일이 같아진다.
        
- 옵션
    
    -i : 대소문자를 무시하고 비교
    

참고하면 좋은 글 : [https://websecurity.tistory.com/105](https://websecurity.tistory.com/105)

### ln

링크란 기존의 파일에 또 하나의 새로운 이름 혹은 경로를 부여하는 것을 말합니다. 링크는 윈도우의 바로가기와 유사한데요. 바로가기만 존재하는 윈도우와 달리 링크는 하드 링크, 심볼릭 링크 두 종류가 있습니다.

> 하드 링크
> 

하드 링크를 이해하기 전에 파일이 저장되는 방법부터 알아보도록 하겠습니다.

파일은 디스크의 블럭이라는 단위로 저장됩니다. 파일의 크기가 크면 하나의 파일이 여러개의 블럭에 저장됩니다. 파일이 저장되어있는 블럭들을 가리키는 포인터들이 있는데요, i-node는 이러한 포인터들이 저장된 블럭을 말합니다. 

즉, i-node는 파일이라는 데이터가 저장되어있는 위치 데이터(포인터)를 가지고 있습니다. 이렇게 데이터의 데이터를 메타 데이터라고 합니다. 사실 i-node는 블럭 포인터 외 파일 권한, 링크 수, 사용자 명 등 다양한 정보를 가지고 있지만 여기서는 다루지 않겠습니다.

<p align="center"><img src="../../../images/시스템프로그래밍및보안/2장/2장 명령어-Untitled.png"></p>
UNIX 환경에서 모든 파일은 개별의 i-node를 가지고 있습니다. ls 명령어의 -i 옵션을 통해 파일의 i-node를 확인할 수 있습니다.

하드 링크는 기존 파일을 가리키는 i-node를 복사하여 생성한 직접적인 포인터 파일입니다. 디스크에 저장된 파일에 대 i-node를 원본 파일과 하드 링크 파일이 모두 가리키고 있습니다. 윈도우에는 없는 개념입니다.

<p align="center"><img src="../../../images/시스템프로그래밍및보안/2장/2장 명령어-Untitled 1.png"></p>
> 심볼릭 링크
> 

심볼릭 링크는 새로운 i-node를 생성하여 원본 파일의 i-node를 가리키는 간접적인 포인터 파일입니다. 원본 파일의 경로명을 통해 원본 파일에 대한 포인터 역할을 수행합니다. 윈도우의 바로가기와 유사합니다.

<p align="center"><img src="../../../images/시스템프로그래밍및보안/2장/2장 명령어-Untitled 2.png"></p>
ln 명령어는 **기본적으로 하드 링크**를 생성하며 **-s 옵션을 추가함으로써 심볼릭 링크**를 생성할 수 있습니다.

- 사용법
    
    $ ln [-option] 파일1 파일2
    
    → 파일1에 대한 새로운 링크로 파일2를 생성
    
    $ ln [-option] 파일1 디렉토리
    
    → 파일1에 대한 새로운 링크를 지정된 디렉토리에 **같은 이름**으로 생성
    

> 복사 vs 링크
> 

복사와 링크, 둘 다 기존의 파일에서 새로운 파일을 생성한다는 것은 동일합니다. 그러나 둘은 성격이 완전 다릅니다. 그 차이를 표로 살펴보겠습니다.

| 복사 | 링크 |
| --- | --- |
| 개별의 별도 파일 생성 | 이름만 다르고 내용은 동일 |
| 둘 중 하나를 수정해도 다른 파일에 영향을 주지 않음 | 둘 중 하나를 수정하면 다른 파일도 똑같이 수정됨 |
| 같은 파일을 별도로 수정하여 작업할 때 사용 | 파일을 공동으로 관리할 때 사용 |

> 하드 링크 vs 심볼릭 링크
> 

| 하드 링크 | 심볼릭 링크 |
| --- | --- |
| 원본을 지우면 하드 링크가 원본의 역할을 대신함 | 원본을 지우면 심볼릭 링크로 데이터에 접근 불가능 |
| 디렉토리에 대한 하드 링크는 슈퍼 유저만 가능 | 디렉토리에 대한 심볼릭 링크는 일반 사용자도 가능 |
| 물리적으로 다른 파일 시스템 간의 하드 링크 불가 | 물리적으로 다른 파일 시스템 간의 심볼릭 링크 가능 |