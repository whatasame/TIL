# 3장 라이브러리

## 라이브러리란?

- 다른 프로그램들과 링크되기 위하여 존재하는 하나 이상의 서브루틴(subroutine)이나 함수(function)들의 집합 파일이다.
서브루틴(subroutine) : 반환값이 없는 함수
- 재사용의 가능성이 많은 코드들을 반복적으로 작성하지 않고 필요한 곳에서 언제든지 호출하요 사용하기 위해 만들었다.
- 컴파일 단계에서 링크될 수 있도록 미리 컴파일하여 목적 코드(object code) 형태로 존재하기에 컴파일 시간이 단축된다.

<aside>
💡 Linux 환경에선 /usr/lib에 컴파일러가 제공하는 표준 라이브러리가 있습니다.

</aside>

## 라이브러리 바인딩

프로그램을 개발할 때 라이브러리의 함수를 사용했다고 가정해봅시다. 프로그램을 컴파일 할 때 링킹 과정에서 라이브러리의 오브젝트 파일과 프로그램의 오브젝트 파일이 연결됩니다. 이러한 연결 과정을 라이브러리 바인딩이라고도 부릅니다. 이러한 라이브러리 바인딩은 정적 바인딩, 동적 바인딩 2가지로 구분할 수 있습니다.

### 정적 라이브러리 바인딩(정적 링킹)

정적 라이브러리 바인딩는 라이브러리 오브젝트 파일의 내용이 소스 코드의 오브젝트 파일과 함께 링크되는 것을 말합니다.

👍 **장점**

- 실행 파일이 라이브러리 데이터를 가지고 있으므로 라이브러리가 필요 없다.
- 실행 속도가 빠르다.

실행 파일 안에 라이브러리 데이터가 있으므로 다른 환경에서 프로그램을 실행 할 때 별도의 라이브러리 설치 과정이 필요하지 않습니다. 또한, 메모리에 프로그램과 라이브러리가 모두 적재되므로 CPU가 라이브러리 데이터를 한 번에 참조할 수 있습니다.

👎 **단점**

- 실행 파일 크기가 크다.
- 라이브러리 전체를 링크하기 때문에 사용하지 않는 함수도 링크된다.
- 라이브러리에 수정 사항이 생기면 파일 전체를 컴파일해야한다.

### 동적 라이브러리 바인딩(동적 링킹)

동적 라이브러리 바인딩은 프로그램을 실행할 때(Runtime) 라이브러리 내용이 링크되는 것을 말합니다. 

동적 라이브러리 바인딩은 컴파일의 링킹 단계에서 라이브러리 모듈을 링크하지 않고 해당 모듈의 주소만 링크합니다. 이후 프로그램이 실행되는 런타임에 실행 파일과 라이브러리가 메모리에 적재되면 실행 파일은 라이브러리 모듈의 주소값으로 이동하여 필요한 모듈을 참조합니다. 이러한 과정은 운영체제에 의해 진행됩니다.

👍 **장점**

- 실행 파일 크기가 작다.
- 공유 라이브러리 사용하다.

👎 **단점**

- 라이브러리가 필요하다.
- 실행 속도가 느리다.

<p align="center"><img src="../../images/시스템프로그래밍및보안/3장 라이브러리-Untitled.png"></p>

라이브러리 모듈을 포함한 채로 실행 파일이 메모리에 적재되는 정적 라이브러리 바인딩과 달리 동적 라이브러리 바인딩은 실행 파일에 라이브러리 모듈의 주소값만 링크되므로 파일의 크기가 작다는 장점이 있습니다. 또한, 동적 라이브러리 바인딩은 실행 파일과 라이브러리가 구분되어 메모리에 적재되므로 동일한 라이브러리가 필요한 실행 파일이 여러 개 있을 때 하나의 라이브러리를 여러 실행 파일이 공유하여 메모리 공간을 아낄 수 있다는 장점이 있습니다. 그러나 CPU가 실행 파일을 참조하고 실행 파일의 라이브러리 모듈 주소값을 한 번 더 참조하므로 정적 라이브러리 바인딩에 비해 실행 속도가 느리다는 단점이 있습니다.

### 동적 vs 정적 라이브러리 바인딩 파일 크기 비교

<p align="center"><img src="../../images/시스템프로그래밍및보안/3장 라이브러리-Untitled 1.png"></p>

정적 라이브러리 바인딩으로 컴파일한 static-hello와 동적 라이브러리 바인딩으로 컴파일한 hello의 파일 크기가 약 55배 정도 차이납니다.

### 라이브러리 바인딩의 예

```c
char cmd[64];
extern char pat[];

foo(void)
{
    if (cmd[0] == 'a')
    {
        memcpy(pat, &cmd[2], 4);
        exe_a(pat[0]);
    }
    else
    {
        memcpy(pat, &cmd[2], 62);
    }
}

void exec_a(char data)
{
    // do something
}
```

위와 같은 소스 코드를 컴파일 할 때 변수와 함수를 구분하면 아래와 같습니다.

- 코드에 정의되어 있음 : cmd, exec_a
- 코드에 정의되어 있지 않음 : pat, memcpy

소스 코드에 정의되어 있지 않은 라이브러리의 변수와 함수는 링킹 단계에서 주소가 결정되면 주소로 변환됩니다.

<p align="center"><img src="../../images/시스템프로그래밍및보안/3장 라이브러리-Untitled 2.png"></p>

이후 런타임에 해당 모듈의 주소로 가서 라이브러리 내용을 참조하는 것입니다.