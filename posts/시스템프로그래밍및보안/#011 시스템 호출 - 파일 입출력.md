# #011 시스템 호출 - 파일 입출력

이번 글에서는 파일 입출력에 관련된 시스템 호출에 대해 알아보도록 하겠습니다.

## UNIX 운영체제의 파일

우선, 시스템 호출의 대상이 되는 파일에 대해 짚고 가겠습니다.

### 파일이란?

- 연속된 바이트의 나열
- 파일별로 특별한 포맷을 정의하지 않음
- 디스크에 저장된 파일뿐만 아니라 외부 장치에 대한 인터페이스도 파일로 구현

### 파일의 종류

- 텍스트 파일(Text file)
    - 사람들이 읽을 수 있는 문자들을 저장하고 있는 파일
    - ASCII 코드 값으로 저장되고 해석
- 이진 파일(Binary file)
    - 있는 그대로 바이트의 연속으로 저장
    - 메모리에 저장된 변수 값을 그대로 이진 파일로 저장 가능

텍스트 파일도 파일이므로 바이트의 연속인가? 그렇다면 0과 1로 구성되어 있는데 ASCII 코드로 인코딩되어 있는 건가?

## 파일 열기 - open()

`open()`은 파일을 여는 시스템 호출입니다. UNIX 환경에선 파일을 사용하려면 시스템 호출을 이용하여 파일을 열어야합니다. 

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(const char* path, int oflag, [mode_t mode]);
```

- path : 파일의 이름 → 파일 경로
- oflag : open flag → 파일을 어떤 형태로 지정할 것인지에 대한 Flag
- mode : 파일의 권한 → chmod의 권한과 같은 형식

`open()` 은 파일 열기를 성공하면 해당 파일의 파일 디스크립터를 반환하고, 실패하면 -1를 반환합니다.

> 파일 디스크립터(File discribtor)는 1씩 증가하는 양수로서 각각의 값은 하나의 파일 경로와 매핑되어 있습니다. UNIX 운영체제에서 프로세스가 파일에 접근할 때, 파일 디스크립터의 번호를 참조하여 매핑된 파일에 접근합니다. 0, 1, 2는 각각 표준 입력, 표준 출력, 표준 에러로 미리 할당되어 있습니다. 따라서, 사용자의 파일 디스크립터는 3부터 시작합니다.
> 

### oflag의 종류

- O_RDONLY : Read Only → 읽기 모드. read()은 사용 가능
- O_WRONLY : Write Only → 쓰기 모드. write()은 사용 가능
- O_RDWR : Read/Write → 읽기/쓰기 모드. read(), write() 사용 가능

- O_APPEND : 파일의 끝에 데이터를 이어 씀
- O_CREAT : path에 해당하는 파일이 없을 경우 파일을 생성한다. option 매개 변수인 **mode를 통해 생성한 파일의 사용 권한을 지정**할 수 있다. CREATE가 아니라 CREAT임을 주의
- O_EXCL : O_CREAT와 함께 사용되어 path에 해당하는 파일이 있는 경우 오류를 출력
- O_TRUNC : 파일이 이미 있는 경우 **해당 파일의 내용을 지우고** 파일을 엶

- O_NONBLOCK : non-blocking 모드로 버퍼를 사용하도록 한다.
- O_SYNC : write()할 때 디스크에 물리적으로 쓴 후 반환된다.

### open()의 활용 예

- `open("account", O_RDONLY);`
    
    현재 경로의 account 파일을 읽기 전용으로 연다.
    
- `open(argv[1], O_RDWR);`
    
    응용 프로그램을 실행할 때 매개변수로 입력받은 첫 번째 파일을 읽기/쓰기 모드로 연다.
    
- `open(argv[1], O_RDWR|O_CREAT, 0600);`
    
    응용 프로그램을 실행할 때 매개변수로 입력받은 첫 번째 파일을 읽기/쓰기 모드로 연다. 만약, 매개변수로 입력받은 파일이 존재하지 않는 경우 0600 권한을 가진 파일로 생성하고 연다.
    
- `open("tmpfile", O_WRONLY|O_CREAT|O_TRUNC, 0600);`
    
    현재 경로의 tmpfile 파일을 쓰기 전용으로 연다. tmpfile이 존재하는 경우 해당 내용을 전부 지우고 파일을 연다. 만약, tmpfile이 존재하지 않는 경우 0600 권한을 가진 파일로 생성하고 연다.
    
- `open("/sys/log", O_WRONLY|O_APPEND|O_CREAT, 0600);`
    
    /sys/log 파일을 쓰기 전용으로 연다. /sys/log 파일이 존재하는 경우 파일의 끝에서부터 이어쓴다. /sys/log 파일이 존재하지 않는 경우 0600 권한을 가진 파일로 생성하고 연다.
    
- `open("tmpfile", O_WRONLY|O_CREAT|O_EXCL, 0600);`
    
    현재 경로의 tmpfile이 없는 경우에만 0600 권한으로 생성하고 연다. tmpfile이 있는 경우 오류를 출력한다.
    

### open()을 활용한 응용 프로그램

파일 읽기를 성공하면 성공 메시지를 출력하고 그렇지 않으면 에러 메시지를 출력하는 프로그램입니다.

```c
#include <stdio.h>
#include <stdlib.h> // exit()
#include <unistd.h> // close()
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h> // open()
int main(int argc, char *argv[])
{
    int fd;

    if ((fd = open(argv[1], O_RDONLY)) == -1)
    { // 파일 열기에 실패한 경우
        perror(argv[1]);
        exit(1);
    }

    printf("File open sucess! : %s\n", argv[1]);
    close(fd);
    exit(0);
}
```

## 파일 닫기 - close()

`close()` 는 파일을 닫는 시스템 호출입니다. `open()`으로 연 파일을 앞으로 사용하지 않을 경우 `close()`를 사용하여 닫아줘야합니다. 그렇지 않으면 시스템에서 계속 남아있게 되고, 시스템 성능 저하를 유발할 수 있습니다.

```c
#include <unistd.h>
int close(int fd);
```

- fd : 닫으려는 파일의 파일 디스크립터

`close()` 은 파일 닫기에 성공하면 0을 반환하고 실패하면 -1을 반환합니다.

## 파일 읽기 - read()

`read()`는 파일의 데이터를 읽는 시스템 호출입니다.

```c
#include <unistd.h>
ssize_t read(int fd, void* buf, size_t nbytes);
```

- fd : 데이터를 읽으려는 파일의 파일 디스크립터
- buf : 파일에서 읽은 데이터가 임시 저장되는 버퍼
- nbytes : 한 번 읽을 때 버퍼에 저장할 데이터의 크기

`read()`는 파일 읽기에 성공하면 읽은 데이터의 Byte 수를 반환하고, 파일 읽기에 실패하면 -1을 반환합니다. 만약, 파일의 끝을 만나면 0을 반환합니다.

### read()를 활용한 응용 프로그램

파일의 크기를 계산하는 프로그램입니다.

```c
#include <stdio.h>
#include <stdlib.h> // exit()
#include <unistd.h> // close(), read()
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h> // open()

int main(int argc, char const *argv[])
{
    /*
     * BUFSIZE는 stdio.h에 미리 정의되어 있는 상수. 환경에 따라 다르다.
     * ssize_t는 signed integer type
     */
    int fd;                 // 파일 디스크립터
    char buffer[BUFSIZ];    // 버퍼
    ssize_t readByte;       // 읽은 크기
    long totalFileSize = 0; // 총 파일 크기

    if ((fd = open(argv[1], O_RDONLY)) == -1)
    {
        perror(argv[1]);
        exit(1);
    }

    // 파일의 끝을 만날 때까지 읽어서 읽은 바이트 수를 저장
    while ((readByte = read(fd, buffer, BUFSIZ)) > 0)
    {
        totalFileSize += readByte;
    }
    printf("File size of %s is %ld byte. \n", argv[1], totalFileSize);

    close(fd);
    exit(0);
}
```

## 파일 쓰기 - write()

`write()`는 파일에 데이터를 쓰는 시스템 호출입니다.

```c
#include <unistd.h>
ssize_t write(int fd, void* buf, size_t nbytes);
```

- fd : 데이터를 쓰려는 파일의 파일 디스크립터
- buf : 파일에 쓸 데이터가 임시 저장되는 버퍼
- nbytes : 버퍼에 있는 데이터 중 한 번에 파일에 쓸 크기

`write()`는 파일 쓰기에 성공하면 쓴 데이터의 Byte 수를 반환하고, 파일 쓰기에 실패하면 -1을 반환합니다. 

### write()를 활용한 응용 프로그램

리눅스 명령어 cp와 유사하게 파일을 복사하는 프로그램입니다.

```c
#include <stdio.h>
#include <stdlib.h> // exit()
#include <unistd.h> // close(), write()
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h> // open()

int main(int argc, char const *argv[])
{
    int fd1, fd2;        // fd1 - 원본 파일, fd2 - 복사될 파일
    char buffer[BUFSIZ]; // buffer
    ssize_t readByte;    // 읽은 크기

    // 예외 처리 1 - 매개 변수로 파일이 2개가 아닐 경우
    if (argc != 3)
    {
        fprintf(stderr, "Use %s file1 file2\n", argv[0]);
        exit(1);
    }
    // 예외 처리 2 - 첫 번째 파일을 여는데 실패한 경우
    else if ((fd1 = open(argv[1], O_RDONLY)) == -1)
    {
        perror(argv[1]);
        exit(2);
    }
    /*
     * 예외 처리 3 - 두 번째 파일을 생성, 열기에 실패한 경우
     * O_CREAT : 파일이 없는 경우 권한이 0644인 파일을 생성 후 열음
     * O_TRUNC : 파일이 있는 경우 파일 내용을 지우고 열음
     */
    else if ((fd2 = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644)) == -1)
    {
        perror(argv[2]);
        exit(3);
    }

    // 파일 복사
    while ((readByte = read(fd1, buffer, BUFSIZ)) > 0)
    {
        write(fd2, buffer, readByte);
    }
    printf("File %s is copied to %s!\n", argv[1], argv[2]);
    exit(0);
}
```

## 파일 생성 - creat()

`creat()`은 

```c
#include <fcntl.h>
int creat(const char* file, mode_t mode);
```

creat()은 close() 안해도되나?

## 파일 디스크립터 복제 - dup(), dup2()

`dup()`은 복제한 파일 디스크립터를 반환하는 시스템 호출입니다.

```c
#include <unistd.h>
int dup(int oldfd);
```

- oldfd : 복제의 대상이 되는 파일 디스크립터. 즉, 원본 파일 디스크립터

`dup()`에 성공할 경우 복제한 파일 디스크립터 번호를 반환하고, 실패할 경우 -1을 반환합니다.

`dup2()`은 복제한 파일 디스크립터를 매개 변수에 대입하는 시스템 호출입니다.

```c
#include <unistd.h>
int dup2(int oldfd, int newfd);
```

- oldfd : 복제의 대상이 되는 파일 디스크립터. 즉, 원본 파일 디스크립터
- newfd : 복제한 파일 디스크립터가 저장되는 변수

`dup2()`에 성공할 경우 복제한 파일 디스크립터 번호를 반환하고, 실패할 경우 -1을 반환합니다.

### 복제된 파일 디스크립터가 가리키는 것

<p align="center"><img src="../../images/시스템프로그래밍및보안/%23011%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%ED%98%B8%EC%B6%9C%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9E%85%EC%B6%9C%EB%A0%A5/Untitled.png"></p>

복제된 파일 디스크립터는 하나의 파일에 대한 여러 개의 파일 디스크립터를 생성하는 것과 같습니다. 즉, 복제된 파일 디스크립터와 원본 파일 디스크립터는 번호가 다르지만 동일한 파일을 가리키고 있습니다. 

이러한 `dup()`과 `dup2()`는 입출력 재지정에 유용하게 사용됩니다. 이는 프로세스 시스템 호출에서 알아보도록 하겠습니다.

### dup()을 활용한 응용 프로그램

파일 하나를 생성하여 해당 파일의 파일 디스크립터를 복제합니다. 이후 복제된 파일 디스크립터와 원본 파일 디스크립터로 데이터를 쓰는 프로그램입니다.

```c
#include <stdio.h>
#include <stdlib.h> // exit()
#include <unistd.h> // write()
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h> // creat()

int main(void)
{
    int originFd, copyFd;

    if ((originFd = creat("dupTest", 0600)) == -1)
    {
        perror("creat error!\n");
        exit(1);
    }

    // 원본 파일 디스크립터에 데이터 쓰기
    write(originFd, "Hello World!\n", 14); // 문자열 13자 + null 문자(\0) 1자 = 14 byte

    // 파일 디스크립터 복제
    copyFd = dup(originFd);

    // 복제한 파일 디스크립터에 데이터 쓰기
    write(copyFd, "Goodbye World!\n", 16); // 문자열 15자 + null 문자(\0) 1자 = 16 byte

    // 각 파일 디스크립터의 번호 확인 -> 각각 다른 숫자 출력
    printf("originFd = %d, copyFd = %d\n", originFd, copyFd); // e.g. 3, 4
    exit(0);
}
```

## 파일 위치 포인터 이동 - lseek()

### 파일 위치 포인터란?

<p align="center"><img src="../../images/시스템프로그래밍및보안/%23011%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%ED%98%B8%EC%B6%9C%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9E%85%EC%B6%9C%EB%A0%A5/Untitled%201.png"></p>

파일 위치 포인터는 파일 내에서 읽거나 쓸 현재 위치를 가리킵니다. 

일반적으로 파일을 읽고 쓸 땐 파일 위치 포인터는 순서대로만 움직입니다. 임의의 위치로 출력 할 수 없습니다. 그러나 `lseek()`를 활용하면 파일 위치 포인터를 임의의 위치로 옮긴 후 해당 값을 출력할 수 있습니다.

### lseek()

`lseek()`는 파일 위치 포인터를 임의의 위치로 이동하는 시스템 호출입니다.

```c
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
```

- fd : 파일 위치 포인터를 이동할 파일의 파일 디스크립터
- offset : 파일 위치 포인터를 이동하는 거리
- whence : 이동의 기준이 되는 곳
    - SEEK_SET : 파일의 시작
    - SEEK_CUR : 현재 파일 위치 포인터가 위치한 곳
    - SEEK_END : 파일의 끝

`lseek()`는 이동을 성공하면 이동한 현재 위치를 반환하고, 실패하면 -1을 반환합니다.

### lseek() -  whence의 활용

- 파일 위치 이동
    - `lseek(fd, 0L, SEEK_SET);`
        
        파일 위치 포인터를 파일의 시작에서 0만큼 뒤로 이동시킵니다. 
        
        즉, 파일 위치 포인터를 파일의 시작점으로 이동시킵니다.
        
    - `lseek(fd, 0L, SEEK_END);`
        
        파일 위치 포인터를 파일의 끝에서 0만큼 뒤로 이동시킵니다. 
        
        즉, 파일 위치 포인터를 파일의 끝으로 이동시킵니다.
        
    - `lseek(fd, 100L, SEEK_SET);`
        
        파일 위치 포인터를 파일의 시작에서 100만큼 뒤로 이동시킵니다.
        
        > offset에 붙은 L은 해당 값의 자료형이 long임을 명시하는 것입니다.
        > 
    
- 레코드 단위 이동
    - `lseek(fnd, n * sizeof(record), SEEK_SET);`
        
        파일 위치 포인터를 파일의 시작에서 레코드 n개 크기만큼 뒤로 이동시킵니다.
        
    - `lseek(fd, sizeof(record), SEEK_CUR);`
        
        파일 위치 포인터를 현재 위치에서 레코드 1개 크기만큼 뒤로 이동시킵니다.
        
    - `lseek(fd, -sizeof(record), SEEK_CUR);`
        
        파일 위치 포인터를 파일의 끝에서 레코드 1개 크기만큼 앞으로 이동시킵니다.
        
    
- 파일 끝을 넘어 이동
    - `lseek(fd, sizeof(record), SEEK_END);`
        
        파일 위치 포인터를 파일의 끝에서 레코드 1개 크기만큼 뒤로 이동시킵니다.
        
        즉, 레코드 1개 크기만큼 빈 공간이 발생합니다.
        

### 파일의 끝을 넘어가는 경우의 예

📜 **소스코드**

```c
write(fd, &record1, sizeof(record));
write(fd, &record2, sizeof(record));
lseek(fd, sizeof(record), SEEK_END); 
write(fd, &record3, sizeof(record));
```

🖨️ **결과**

<p align="center"><img src="../../images/시스템프로그래밍및보안/%23011%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%ED%98%B8%EC%B6%9C%20-%20%ED%8C%8C%EC%9D%BC%20%EC%9E%85%EC%B6%9C%EB%A0%A5/Untitled%202.png"></p>
