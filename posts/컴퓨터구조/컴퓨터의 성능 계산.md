# 컴퓨터의 성능 계산

---

### What is Clock?

컴퓨터의 성능에 대해 알아보기전에 클럭(Clock)을 먼저 알아보도록 하겠습니다.

우리가 사용하는 크롬 브라우저, 카카오톡 등 모든 프로그램은 수많은 명령어로 구성됩니다. 프로그램은 어떻게 컴퓨터에 실행이 될까요?

컴퓨터가 프로그램을 실행하기 위해선 SSD, HDD와 같은 저장 장치에 있는 프로그램을 메모리에 불러옵니다. 이후 CPU는 메모리에 저장된 프로그램의 명령어들을 한 줄씩 읽어와 해석하고 실행하죠. 다시 말해, CPU는 메모리의 값을 읽고(Fetch), 해석하고(Decode), 실행하는 것(Execute)을 끊임없이 반복(Cycle)합니다.

<p align="center"><img src="../../images/컴퓨터구조/컴퓨터의 성능 계산-Untitled.png"></p>
이러한 CPU의 Cycle을 수행할 수 있도록 하는 장치가 **Clock**입니다. 시계의 초침이 정확히 1초마다 한 칸씩 움직이듯 Clock도 CPU의 Cycle 단계를 하나씩 수행할 수 있도록 전기 신호를 보냅니다.

그렇다면 Clock Cycle은 무엇일까요? Clock cycle은 CPU가 Clock의 전기 신호에 의해 Cycle을 1회 반복하는 것입니다. 이때 CPU가 Clock cycle을 반복하는 속도가 Clock cycle speed이고 Hz로 표시합니다.

이제 우리가 사용하는 CPU에 붙는 Hz가 무엇을 의미하는지 알게되었습니다. 3.2GHz의 CPU는 메모리에 저장된 명령어를 읽고 해석하고 실행하는 것을 1초에 32억번 수행하는 CPU입니다.

### Components of performance

컴퓨터의 성능을 결정하는 요소는 어떤 것이 있을까요?

- CPU execution time for a program
    
    CPU가 프로그램을 실행하는데 걸린 시간
    
- Instruction count
    
    명령어(Instruction)의 수(Count)
    
    프로그램은 메모리에 저장되어 실행되므로 명령어가 많을수록 메모리의 공간을 많이 차지
    
- Clock cycle Per Instruction(CPI)
    
    명령어를 실행하는데 필요한 클럭 주기의 수. 
    예를 들어, 명령어의 CPI가 5이면 해당 명령어를 실행하기 위해 5의 클럭 주기가 필요하다는 뜻
    
    가장 간단한 명령어의 경우 CPI가 1
    
    CPI가 클수록 해당 명령어에 필요한 클럭수가 증가
    
    CISC는 CPI가 높지만 명령어 수가 적고, RISC는 CPI가 낮지만 명령어의 수가 높음
    
- Clock cycle time
    
    클럭 주기 시간으로서 하나의 클럭 주기가 완료되는데 필요한 시간
    

클럭을 박수로 비유하면 다음과 같습니다.

- 박수 3번을 치면 물을 가져다 줌 → 물을 얻기 위해 필요한 CPI는 3
- 내가 박수 1번 치는데 필요한 시간이 1초 → Clock cycle time = 1초

### Response Time, Throughput

컴퓨터 성능을 평가하는 기준에는 2가지가 있습니다.

- Response Time(Execution Time)
    
    작업의 시작부터 종료까지 걸린 시간
    
    개별의 사용자 관점에서 중요한 요소 → 프로그램이 늦게 실행되면 사용자의 불만이 증가
    
- Throughput(Bandwidth)
    
    주어진 시간 당 처리한 작업의 양
    
    시스템 관점에서 중요한 요소 → 개인 사용자의 경험보다 시간당 처리양이 많아야 함
    

성능 평가 기준은 컴퓨터 환경에 따라 다릅니다. 임베디드 시스템이나 데스크탑 컴퓨터에서는 Response time에 초점을 둘 것이고, 서버의 경우 Throughput에 초점을 둘 것입니다.

그런데, 사실 Response time을 줄이는 것이 결국 Throughput을 줄이는 것과 동일합니다.

### Measuring performance

$$
Performance_x = \frac{1}{Execution\ time_x}
$$

성능이 좋다는 것은 작업을 처리하는 시간이 짧다는 것입니다. 즉, 성능을 최대화하기 위해선, 실행 시간을 최소화해야합니다.

$$
\frac{Performance_x}{Performance_y} = \frac{Execution\ time_y}{Execution\ time_x} = n
$$

X가 Y보다 성능이 n배 좋을 때,  n을 구하는 방법은 위와 같습니다. 

예를 들어 같은 프로그램을 실행하는데 있어 A가 10초, B가 15초가 걸렸을 때 A는 B보다 몇 배 빠를까요?

$$
\frac{Execution\ time_B}{Execution\ time_A} = \frac{15}{10} = 1.5
$$

사실 공식이 없어도 직관으로 쉽게 구할 수 있습니다. 그래도 식을 알아두면 명확하게 알 수 있겠죠?

### Measuring execution time

- Elapsed time
    
    Processing, I/O, OS overhead(scheduling)을 모두 합친 전체 실행 시간을 측정한 것
    
- CPU time
    
    주어진 작업을 처리하는 시간만 측정한 것. Elapsed time과 달리 I/O 등의 시간은 포함되지 않음
    

Elapsed time은 컴퓨터 구조 설계자가 고려할 수 없는 것(e.g. I/O Device)의 영향을 많이 받습니다. 따라서 순수 처리 시간인 CPU time이 성능 측정에서 중요한 요소입니다.

### How to Calculate CPU time

그렇다면 CPU time(CPU execution time)은 어떻게 계산할까요?

1. CPU execution time = 프로그램이 필요한 CPU clock cycle의 수 × Clock cycle time
    
    박수 5번이 필요한 프로그램에서 박수를 1번 치는데 필요한 시간이 2초면 총 실행 시간은 10초입니다.
    
2. CPU execution time = 프로그램이 필요한 CPU clock cycle의 수 × **Clock rate**
    
    $$
    {Clock\ rate} = \frac{1}{Clock\ cycle\ time}
    $$
    
    - Clock cycle time : 1번의 클럭에 필요한 시간 $1ns$
        
        박수 1번을 치는 데 필요한 시간 → 박수 1번에 필요한 시간 **2초** 
        
    - Clock rate : 1.0GHz CPU는 1초에  $10^9$번의 클럭을 처리한다.  ****(inversion of clock cycle time)
        
        1초에 치는 박수의 수 → 1초에 박수 **0.5번**
        
    
    박수가 5번 필요한 프로그램에서 1초에 치는 박수가 0.5번이면 총 실행 시간은 10초입니다.
    

**예제**

특정 프로그램을 실행하는데 2GHz CPU를 가진 A 컴퓨터가 10초가 걸렸다. B 컴퓨터는 6초가 걸렸을 때 B의 Cycle rate는 얼마인가? (단, B 컴퓨터는 동일한 프로그램임에도 불구하고 모종의 이유로 A보다 1.2배의 Clock cylce이 필요했다.)

→ 문제에서 주어진 값이 GHz이므로 CPU Clock rate를 알려주었습니다.

$$
CPU\ time_A = \frac{CPU\ clock\ cycles_A}{Clock\ rate_A}
$$

따라서 A가 실행한 프로그램이 필요한 Clock cycle은 아래와 같습니다.

$$
{CPU\ clock\ cycles_A} = CPU\ time_A \times {Clock\ rate_A} = 10sec\ \times\ 2GHz
$$

이제, B가 실행한 프로그램의 필요한 Clock cycle을 구해보겠습니다. B 컴퓨터는 동일한 프로그램임에도 불구하고 모종의 이유로 A보다 1.2배의 Clock cylce이 필요했다고 했습니다.

$$
{CPU\ clock\ cycles_B} = {CPU\ clock\ cycles_A}\ \times\ 1.2 = 10sec\ \times\ 2GHz\ \times\ 1.2
$$

따라서, B 컴퓨터의 CPU rate는 아래와 같습니다.

$$
Clock\ rate_B =\frac{CPU\ clock\ cycle_B}{CPU\ time_B}=\frac{10sec\ \times\ 2GHz\ \times\ 1.2}{6sec}=4GHz
$$

그렇다면 모종의 이유는 도대체 무엇일까요? 두 컴퓨터의 구조가 달랐던 것입니다. 

예를 들어 B컴퓨터가 RISC이고 A 컴퓨터가 CISC였다면 B컴퓨터가 A보다 명령어 수가 1.2배 많아서 느렸던 것이죠. 또, 반대의 경우 B 컴퓨터가 명령어의 수는 적지만 CPI가 높기 때문에 A 컴퓨터보다 필요한 클럭수가 많았던 것이죠. 

결국 컴퓨터 구조의 차이로 인해 B 컴퓨터는 2배 빠른 4GHz의 CPU를 가지고 있지만 A보다 정확히 2배 빠를 순 없었던 겁니다.

### Average CPI

CPI는 Clock cycle Per Instruction으로서 명령어마다 필요한 클럭의 수를 뜻합니다. 그러나 컴퓨터 구조를 비교할 때 기존의 CPI 개념으론 비교가 어려워 Average CPI를 계산하여 비교합니다.

<p align="center"><img src="../../images/컴퓨터구조/컴퓨터의 성능 계산-Untitled 1.png"></p>
위 그림에서 CPI가 바로 Average CPI입니다. RISC는 간단한 명령어가 많고, CISC는 복잡한 명령어가 적은 특징을 갖고 있는데 위 표가 그 특징을 아주 잘 보여주고 있습니다.

$$
Average\ CPI =\frac{Total\ of\ CPU\ Cycle\ clocks}{Instruction\ count} = \frac{\sum_{n}^{i}(CPI_i\ \times\ IC_i)}{Instruction\ count} 
$$

Average CPI를 구하는 방법은 아주 간단합니다. 전체 CPU Clock cycle를 명령어 수로 나누면 됩니다.
여기서 $i$는 해당 컴퓨터의 명령어 집합 구조(ISA)가 가지는 명령어 타입을 의미합니다.

예를 들어, CPI가 5짜리 A 명령어가 3개, CPI가 3인 B 명령어가 7개 있을 때, Average CPI는 아래와 같습니다. 

$$
Average\ CPI = \frac{5\times3\ +\ 3\times7}{5\ +\ 3}=4.5
$$

한편, Average CPI는 Effective CPI라고도 부르니 참고하시길 바랍니다.

**예제**

컴퓨터 A와 B가 ISA가 같을 때 컴퓨터 A는 $250ps$의 Clock rate와 2.0의 Average CPI를 가지고 있고, 컴퓨터 B는 $500ps$의 Clock rate와 1.2의 Average CPI를 가지고 있다. 같은 프로그램을 컴퓨터 A와 B가 실행할 때 어떤 컴퓨터가 얼마나 빠른가?

→ 우선 각 컴퓨터가 프로그램을 실행하는데 필요한 시간은 다음과 같습니다.

$$
CPU\ time_A = IC\ \times\ Average\ CPI_A\ \times\ Clock\ rate_A = IC\ \times 250ps\ \times\ 2.0
$$

$$
CPU\ time_B = IC\ \times\ Average\ CPI_B\ \times\ Clock\ rate_B = IC\ \times 500ps\ \times\ 1.2
$$

성능을 비교하는 방법은 위의 **Measuring performance**에서 알아봤습니다.

$$
\frac{Performance_A}{Performance_B} = \frac{Execution\ time_B}{Execution\ time_A} = \frac{600\ \times\ IC\ ps}{500\ \times\ IC\ ps} = 1.2
$$

따라서 A 컴퓨터가 B 컴퓨터보다 1.2배 빠릅니다.

### 종합문제

**문제 1**

하나의 프로그램이 서로 다른 방식으로 컴파일되어 아래와 같이 2개의 시퀀스로 나뉘었을 때 어떤 시퀀스가 더 성능이 우수한가?

<p align="center"><img src="../../images/컴퓨터구조/컴퓨터의 성능 계산-Untitled 2.png"></p>
> Sequence 1
> 

총 명령어의 개수 = A타입 명령어 2개 + B 타입 명령어 1개 + C 타입 명령어 2개 = $5$

총 CPU Cycle Clock = $1\times2\ +\ 2\times1\ +\ 3\times2\ = 10$ 

Average CPI =$10\div 5 = 2$

> Sequence 2
> 

총 명령어의 개수 = A타입 명령어 4개 + B 타입 명령어 1개 + C 타입 명령어 1개 = $6$

총 CPU Cycle Clock = $1\times4\ +\ 2\times1\ +\ 3\times1\ = 9$

Average CPI =$9\div6 = 1.5$

d

따라서, Sequence 2가 Sequence 1보다 우수합니다.

<aside>
💡 Sequence 2가 Sequence 1보다 명령어의 개수는 1개 더 많지만 CPI가 낮은 A 명령어의 비율이 높기 때문에 Average CPI가 낮았습니다. 따라서 우리는 컴퓨터 성능 향상을 위해 비율이 높은 명령어. 즉, **Common case의 성능을 높이는 것이 중요**한 것을 기억해야합니다.

</aside>

---

**문제 2**

아래의 표에는 명령어 타입과 타입별 빈도수, CPI가 명세되어있다. 이때, 따름 질문을 해결하라

<p align="center"><img src="../../images/컴퓨터구조/컴퓨터의 성능 계산-Untitled 3.png"></p>
> **따름 질문 1.** 
Average CPI를 구하라.
> 

<p align="center"><img src="../../images/컴퓨터구조/컴퓨터의 성능 계산-Untitled 4.png"></p>
> **따름 질문 2.** 
데이터 캐쉬가 향상으로 Load 명령어의 CPI가 2로 줄었다. 이때, 성능은 얼마나 좋아지는가?
> 

<p align="center"><img src="../../images/컴퓨터구조/컴퓨터의 성능 계산-Untitled 5.png"></p>
→ Average CPI가 1.6이 되므로 2.2/1.6 = 1.375 → 37.5% 향상

> **따름 질문 3.**
Branch 예측을 통해 Branch CPI가 1로 줄었다. 이때, 성능은 얼마나 좋아지는가?
> 

<p align="center"><img src="../../images/컴퓨터구조/컴퓨터의 성능 계산-Untitled 6.png"></p>
→ Average CPI가 2.0이 되므로 2.2/2.0 = 1.1 → 10% 향상

> **따름 질문 4.**
ALU Path를 2배 늘려 ALU CPI가 0.5로 줄었다. 이때, 성능은 얼마나 좋아지는가?
> 

<p align="center"><img src="../../images/컴퓨터구조/컴퓨터의 성능 계산-Untitled 7.png"></p>
→ Average CPI가 1.95이 되므로 2.2/1.95 = 1.128 → 12.8% 향상