# #015 데이터 종속성과 정규화

이번 글에서는 관계형 데이터베이스$^{RDBMS}$의 설계를 잘못할 경우 발생할 수 있는 문제와 이러한 문제가 생기지 않도록 설계하는 방법에 대해 알아보도록 하겠습니다.

## RDBMS를 잘못 설계할 경우 발생하는 문제점

관계형 데이터베이스를 잘못 설계할 경우 발생하는 문제점은 아래와 같습니다.

- 정보의 중복
- 특정 정보를 나타낼 수 없음
    - 삽입 이상$^{insert\ anomaly}$
    - 삭제 이상$^{delete\ anomaly}$
    - 갱신 이상$^{update\ anomaly}$

아래의 잘못 설계된 예시 테이블을 보겠습니다.

<p align="center"><img src="../../images/데이터베이스/%23015%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%A2%85%EC%86%8D%EC%84%B1%EA%B3%BC%20%EC%A0%95%EA%B7%9C%ED%99%94/Untitled.png"></p>

위 테이블은 대출$^{lending}$ 정보를 나타내는 테이블입니다. 주 키는 Loan-number입니다.

이 테이블의 문제점은 다음과 같습니다.

- 정보의 중복
    
    서로 다른 레코드에 대하여 빨간색 네모로 강조된 부분이 중복됩니다.
    
- 특정 정보를 나타낼 수 없음
    - 삽입 이상
        
        신규 레코드. 즉, 은행 지점$^{Branch-name}$이 새로 생겨 대출한 사람이 아무도 없는 레코드를 삽입하려고 할 때, 주 키인 Loan-number의 부재로 삽입을 할 수 없다.
        
    - 삭제 이상
        
        Williams가 대출을 모두 갚아 Williams에 해당하는 레코드를 삭제할 때 이 테이블에 유일하게 있는 Pownal 지점에 대한 정보가 삭제되므로 삭제하면 문제가 발생.
        
    - 갱신 이상
        
        Downtown 지점에서 대출한 Jones가 대출금을 일부 갚으면 자금$^{Assets}$의 변동이 생기는데 다른 레코드의 자금도 수정해야한다. 즉, 레코드 하나에 변경 사항이 생기면 여러 레코드도 수정해야하는 문제 발생
        

이러한 문제는 은행 정보와 고객 정보를 하나의 테이블에서 관리하기 때문에 발생합니다. 따라서 우리는 은행 정보와 고객 정보를 따로 관리할 필요가 있습니다.

## 테이블을 분할하자

분할$^{decomposition}$은 하나의 릴레이션을 여러 릴레이션으로 나누는 것을 말합니다. 분할을 통해 위에서 발생한 정보 중복과 이상 현상을 해결할 수 있습니다.

### 분할의 정의

$R=R_1\cup R_2\cup  ... \cup R_n$ 을 만족하는 $\{R_1,R_2,...,R_n\}$를 **R의 분할**이라고 합니다.

> R은 테이블 r의 스키마를 말합니다.
> 

### 분할도 잘 해야한다 - 정보 손실

정보 중복과 이상 현상과 같은 문제는 관계형 데이터 베이스의 설계를 잘못함으로써 발생한 문제입니다. 이를 해결하기 위해 분할을 하는데, 이러한 분할도 잘못 분할할 경우 **정보 손실**$^{information\ loss}$이라는 새로운 문제를 낳습니다.

아래 사진은 위 테이블을 두 개의 테이블로 분할한 예입니다.

<p align="center"><img src="../../images/데이터베이스/%23015%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%A2%85%EC%86%8D%EC%84%B1%EA%B3%BC%20%EC%A0%95%EA%B7%9C%ED%99%94/Untitled%201.png"></p>

위와 같은 분할은 잘못된 분할이라고 할 수 있습니다. 왜 잘못 분할한 것일까요? 

<p align="center"><img src="../../images/데이터베이스/%23015%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%A2%85%EC%86%8D%EC%84%B1%EA%B3%BC%20%EC%A0%95%EA%B7%9C%ED%99%94/Untitled%202.png"></p>

문제는 분할된 테이블을 Join할 때 발생합니다. 분할할 때 주 키가 아닌 속성$^{Customer-name}$으로 분할하였기 때문에 기존 테이블에 없던 레코드가 새롭게 만들어지는 문제가 발생합니다.

<p align="center"><img src="../../images/데이터베이스/%23015%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%A2%85%EC%86%8D%EC%84%B1%EA%B3%BC%20%EC%A0%95%EA%B7%9C%ED%99%94/Untitled%203.png"></p>

- (Downtown, Brooklyn, 9000000, Jones), (Mianus, Horseneck, 4000000, Jones)
- (Jones, L-17, 1000), (Jones, L-93, 500)

위와 같은 레코드에서 기존에 없던 (Downtown, Brooklyn, 9000000, Jones, L-93, 500)과 같은 새로운 레코드가 발생하게 됩니다. 이러한 문제를 **정보 손실**이라고 합니다.

### 정보 손실을 막는 방법 - 무손실 조인 분할

따라서, 우리는 정보 손실이 발생하지 않도록 분할을 할 필요가 있습니다. 정보 손실이 발생하지 않는 분할을 무손실 조인 분할$^{lossless\ join\ decomposition}$이라고합니다.

$r(R)=r(R_1)\Join r(R_2)\Join...\Join r(R_n)$을 만족하는  $\{R_1,R_2,...,R_n\}$를 **R의 무손실 조인 분할**이라고 합니다.

반대로, 위 조건을 만족하지 않으면 손실 조인 분할이라고 합니다.

<p align="center"><img src="../../images/데이터베이스/%23015%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%A2%85%EC%86%8D%EC%84%B1%EA%B3%BC%20%EC%A0%95%EA%B7%9C%ED%99%94/Untitled%204.png"></p>

위에서 사용한 분할의 예시에선 Join의 결과 테이블과 처음 테이블 $r(R)$이 일치하지 않기 때문에 손실 조인 분할을 한 것입니다.

그렇다면 무손실 조인 분할은 어떻게 할 수 있을까요? 무손실 조인 분할을 하기 위해서는 함수 종속성에 대해 알아야합니다.

## 함수 종속성

### 정의

r의 임의의 두 레코드 $t_1$과 $t_2$에 대하여 $t_1[\alpha]=t_2[\alpha]\rightarrow t_1[\beta]=t_2[\beta]$를 만족하는 $\alpha$와 $\beta$이 있을 때 이들은 함수 종속성이 있다고 말합니다. 

이때, $\beta$는 $\alpha$의 값에 따라 결정되므로 $\beta$는 $\alpha$에 종속된다고 할 수 있습니다.

> $\alpha$와 $\beta$는 릴레이션 r의 속성을 말합니다.
> 

예를 들어, 학생 테이블에선 학번이 같으면 학과가 같습니다. 이를 학번$\rightarrow$학과로 표현할 수 있습니다. 또, 주소가 같으면 우편 번호가 같습니다. 이는 주소$\rightarrow$학과로 표현할 수 있습니다.

<p align="center"><img src="../../images/데이터베이스/%23015%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%A2%85%EC%86%8D%EC%84%B1%EA%B3%BC%20%EC%A0%95%EA%B7%9C%ED%99%94/Untitled%205.png"></p>

위 테이블에서 나타나는 함수 종속성은 아래와 같습니다. 

- $A\rightarrow C$
    
    A의 값이 같은 레코드는 C의 값도 같습니다.
    
- $AB\rightarrow D$
    
    위 테이블에는 A의 값과 B의 값이 같은 레코드가 없습니다. 필요조건의 가정 명제가 $false$이므로 필요 조건의 결론 명제가 무엇이 와도 필요조건은 항상 $true$입니다.
    
    > 필요 조건 진리표
    > 
    > 
    > <p align="center"><img src="../../images/데이터베이스/%23015%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%A2%85%EC%86%8D%EC%84%B1%EA%B3%BC%20%EC%A0%95%EA%B7%9C%ED%99%94/Untitled%206.png"></p>
    > 

### 함수 종속성을 따지는 올바른 방법

지금까지 테이블의 레코드를 살펴보며 $t_1[\alpha]=t_2[\alpha]\rightarrow t_1[\beta]=t_2[\beta]$를 만족하는 레코드를 찾아 함수 종속성을 판단하였습니다. 그러나 테이블의 레코드 내용은 CRUD에 의해 계속 변하므로 레코드 값을 통해 함수 종속성을 판단하는 것은 바람직하지 않습니다. 레코드 값이 변함에 따라 함수 종속성이 달라지기 때문입니다.

따라서 함수 종속성을 미리 정하고 테이블에 레코드가 입력될 때 무결성 검사를 하는 것이 올바른 방법입니다.

## 함수 종속성 집합의 Closure

여러 함수 종속성로 구성된 집합 $F$가 있을 때 $F$의 Closure$^{폐포}$를 $F^+$라고 표현합니다.

### $F^+$의 정의

$F$에 의해 논리적으로 유도될 수 있는 모든 함수 종속성들의 집합

예를 들어, $F=\{A\rightarrow B, B\rightarrow C\}$의 Closure는 아래와 같습니다.

$F^+=\{A\rightarrow B, B\rightarrow C, A\rightarrow C, AB\rightarrow B, BC\rightarrow C, AC\rightarrow BC, \ ...\}$